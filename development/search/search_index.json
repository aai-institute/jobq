{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<ul> <li> <p> Quickstart</p> <p>Build and execute your first workflow with jobq</p> </li> <li> <p> Concepts</p> <p>Learn about the concepts behind jobq</p> </li> <li> <p> Command-line interface</p> <p>Learn how to use the <code>jobq</code> command-line interface</p> </li> <li> <p> API Reference</p> <p>Detailed documentation of the jobq Python API</p> </li> </ul> <p>Early Adopters</p> <p>We are seeking early adopters who would like to actively participate in our feedback process and shape the future of the project. If you are interested in using jobq and want to get in touch with us, please reach out via Github Discussions.</p> <p>This project is licensed under the Apache License, Version 2.0.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to jobq","text":"<p>Thank you for your interest in contributing to this project!</p> <p>We appreciate issue reports, pull requests for code and documentation, as well as any project-related communication through GitHub Discussions.</p>"},{"location":"CONTRIBUTING/#prerequisites","title":"Prerequisites","text":"<p>We use the following development tools for all Python code:</p> <ul> <li>uv</li> <li>pre-commit</li> <li>ruff (also part of the <code>pre-commit</code> hooks)</li> <li>pytest</li> </ul> <p>The development version of Python is 3.12, so please make sure to use that version when developing. The client-side code is tested against Python 3.10 and 3.11, server-side code is tested against Python 3.11, please take this into account when using recent Python features.</p> <p>To get started with development, create a fork of the GitHub repository and clone it to your local machine. Please submit your changes as pull requests against the <code>main</code> branch.</p>"},{"location":"CONTRIBUTING/#working-on-the-client-side-code-decorators-cli","title":"Working on the client-side code (decorators &amp; CLI)","text":"<p>The <code>client/</code> directory contains the source code for the <code>jobq</code> CLI and Python decorators.</p>"},{"location":"CONTRIBUTING/#development","title":"Development","text":"<p>If you want to contribute to the client-side code, you can follow these steps:</p> <ol> <li> <p>Create a virtual environment and install the development dependencies:</p> <pre><code>cd jobq/client\nuv sync --all-extras --dev\n</code></pre> </li> <li> <p>To run the Pytest test suite, run:</p> <pre><code>uv run pytest\n</code></pre> </li> <li> <p>After making your changes, verify they adhere to our Python code style by running <code>pre-commit</code>:</p> <pre><code>uv run pre-commit run --all-files\n</code></pre> <p>You can also set up Git hooks through <code>pre-commit</code> to perform these checks automatically:</p> <pre><code>uv run pre-commit install\n</code></pre> </li> </ol>"},{"location":"CONTRIBUTING/#regenerating-the-api-client","title":"Regenerating the API client","text":"<p>The <code>src/openapi_client</code> folder contains an automatically-generated API client for the backend API.</p> <p>If you make changes to the backend API, you can regenerate the API client with the following command:</p> <pre><code>hack/openapi-regen.sh\n</code></pre> <p>This will regenerate the API client in the <code>client/src/openapi_client</code> directory from a currently running FastAPI server using <code>openapi-generator-cli</code>. Note that you will need to have the backend server running and accessible at <code>http://localhost:8000</code> in order to generate the client code.</p> <p>The script automatically removes unnecessary files and reformats the generated code according to our code style.</p>"},{"location":"CONTRIBUTING/#publishing-to-pypi","title":"Publishing to PyPI","text":"<p>The <code>jobq</code> package is published to PyPI through a GitHub Actions workflow when a new release is created.</p>"},{"location":"CONTRIBUTING/#working-on-the-server-side-code-api","title":"Working on the server-side code (API)","text":"<p>The server-side code under the <code>backend/</code> folder is written in Python and uses the FastAPI framework.</p> <p>You can follow the same instructions as for the client-side code to set up a development environment.</p>"},{"location":"CONTRIBUTING/#running-the-server","title":"Running the server","text":"<p>Since the code can load Kubernetes credentials from an in-cluster Kubernetes service account or from a Kubeconfig file, you can run it locally without having to deploy to a Kubernetes cluster.</p> <p>To run the server locally in development mode (accessible at http://localhost:8000), you can use the following command in the <code>backend/</code> folder:</p> <pre><code>fastapi dev src/jobq_server\n</code></pre> <p>FastAPI will automatically reload the server when you make changes to the code.</p>"},{"location":"CONTRIBUTING/#testing","title":"Testing","text":"<p>Tests are written with pytest and can be run with the following command:</p> <pre><code>uv run pytest\n</code></pre> <p>The end-to-end tests (under <code>tests/e2e</code>) deploy a short-lived Kubernetes cluster and run the tests against those. You will need to have a few tools installed so the test harness can spin up a Kubernetes cluster:</p> <ul> <li>Docker (or another Docker-compatible container runtime like <code>colima</code>)</li> <li>Minikube</li> <li><code>kubectl</code></li> <li>Helm</li> </ul> <p>After the tests have been run, the cluster will be torn down (also if the test fails). If you manually abort a test run (which prevents the automatic deletion), you can use <code>minikube profile list</code> to find the name of the cluster (<code>integration-test-&lt;timestamp&gt;</code>) and then call <code>minikube delete -p &lt;profile-name&gt;</code> to delete the cluster.</p> <p>If you want to run the tests against an existing cluster (which greatly speeds things up), you can provide the name of the context to use through the <code>E2E_K8S_CONTEXT</code> environment variable:</p> <pre><code>E2E_K8S_CONTEXT=minikube uv run pytest\n</code></pre> <p>Warning</p> <p>Running the e2e tests against an existing will clutter the active namespace, please proceed with caution!</p> <p>The test harness attempts to install Kueue and the Kuberay operator into the cluster, so you might run into conflicts if you already have them deployed.</p> <p>If you want to skip the end-to-end tests (e.g., to speed up the test execution), you can use the following command:</p> <pre><code>uv run pytest -m \"not e2e\"\n</code></pre>"},{"location":"CONTRIBUTING/#publishing-docker-images","title":"Publishing Docker images","text":"<p>Docker images are published to GitHub Container Registry through GitHub Actions.</p> <p>Images are tagged according to the following patterns:</p> <ul> <li><code>&lt;version&gt;</code> for release versions</li> <li><code>pr-&lt;pr_number&gt;</code> for pull requests</li> <li><code>main</code> for the <code>main</code> branch</li> <li><code>&lt;branch_name&gt;</code> for other branches</li> </ul> <p>The CI workflow also attaches build attestations to the images, which can be used to verify the integrity of the images.</p>"},{"location":"CONTRIBUTING/#updating-dependencies","title":"Updating dependencies","text":"<p>Dependencies should stay locked for as long as possible, ideally for a whole release. If you have to update a dependency during development, you should do the following:</p> <ol> <li>If it is a core dependency needed for the package, add it to the <code>dependencies</code> section in the <code>pyproject.toml</code>.</li> <li>In case of a development dependency, add it to the <code>dev</code> section of the <code>project.optional-dependencies</code> table instead.</li> <li>Dependencies needed for documentation generation are found in the <code>docs</code> sections of <code>project.optional-dependencies</code>.</li> </ol> <p>After adding the dependency in either of these sections, lock all dependencies again:</p> <pre><code>uv lock\n</code></pre> <p>In addition to these manual steps, we also provide a <code>pre-commit</code> hook that automatically locks the dependencies whenever <code>pyproject.toml</code> is changed.</p> <p>Selective package upgrade for existing dependencies are also handled by the helper script above. If you want to update the Pydantic dependency, for example, simply run:</p> <pre><code>uv add -P pydantic\n</code></pre> <p>Tip</p> <p>Since the official development version is Python 3.12, please run the above commands in a virtual environment with Python 3.12.</p>"},{"location":"CONTRIBUTING/#working-on-documentation","title":"Working on documentation","text":"<p>Improvements or additions to the project's documentation are highly appreciated.</p> <p>The documentation is based on the MkDocs and Material for MkDocs (<code>mkdocs-material</code>) projects, see their homepages for in-depth guides on their features and usage. We use the Numpy documentation style for Python docstrings.</p> <p>Documentation dependencies are defined in the root-level <code>pyproject.toml</code> file.</p> <p>You can start a local documentation server with <code>uv run mkdocs serve</code> (mkdocs listens on port 8000 by default), or generate a static build under the <code>public/</code> folder using <code>uv run mkdocs build</code>.</p> <p>In order to maintain documentation for multiple versions of this library, we use the mike tool to maintain individual documentation builds per version.</p> <p>The GitHub CI pipeline automatically invokes <code>mike</code> as part of the release process with the correct version and updates the GitHub pages branch for the project.</p>"},{"location":"CONTRIBUTING/#contributions-under-repository-license","title":"Contributions under repository license","text":"<p>Any contributions you make need to be under the same Apache 2.0 License that covers the project.</p> <p>See the GitHub Terms of Service for more details on this inbound=outbound policy:</p> <p>Whenever you add Content to a repository containing notice of a license, you license that Content under the same terms, and you agree that you have the right to license that Content under those terms. If you have a separate agreement to license that Content under different terms, such as a contributor license agreement, that agreement will supersede.</p> <p>Isn't this just how it works already? Yep. This is widely accepted as the norm in the open-source community; it's commonly referred to by the shorthand \"inbound=outbound\". We're just making it explicit.</p>"},{"location":"cli/","title":"The <code>jobq</code> command line interface","text":"<p>To interact with a set up cluster queue, you (the data scientist) can use the <code>jobq</code> CLI. It provides subcommands for the basic administrative tasks around your compute jobs, like submitting and deleting jobs, listing, and querying job status information.</p> <p>A prerequisite for using jobq is adding configuration to be able to reach the backend API server talking to the Kubernetes cluster. Currently, only the server URL is required. You can add it directly under a <code>tool.jobq</code> block in your <code>pyproject.toml</code> file like so:</p> <pre><code># \n[tool.jobq]\napi-base-url = \"http://localhost:8000\"\n</code></pre>"},{"location":"cli/#submission-and-termination-of-compute-jobs","title":"Submission and termination of compute jobs","text":"<p>To submit compute jobs to your chosen Kubernetes cluster queue, use the <code>jobq submit</code> command.</p> <pre><code>$ jobq submit -h\nusage: jobq submit [-h] [--api-base-url Url] [--log-level str]\n                   [--mode {ExecutionMode.LOCAL,ExecutionMode.DOCKER,ExecutionMode.KUEUE,ExecutionMode.RAYJOB}]\n                   entrypoint\n\nExecute a job locally or through a jobq server\n\npositional arguments:\n  entrypoint\n\noptions:\n  -h, --help            show this help message and exit\n  --api-base-url Url    Base URL of the jobq API server (required)\n  --log-level str       Output log level (DEBUG, INFO, WARNING, ERROR, CRITICAL) (default: INFO)\n  --mode {ExecutionMode.LOCAL,ExecutionMode.DOCKER,ExecutionMode.KUEUE,ExecutionMode.RAYJOB}\n                        Job execution mode\n</code></pre> <p>Here, <code>entrypoint</code> is the Python file containing your job definition. For more information on how to define compute jobs in Python with <code>jobq</code>, refer to the starter guide [TODO: referral].</p> <p>The command also contains a dry-run facility to prototype your script locally, by passing the <code>--mode=local</code> switch. This way, you can test your workflow on your own local machine before rolling it out to your actual cluster.</p> <p>To stop a previously submitted job, use the <code>jobq stop</code> command.</p> <pre><code>$ jobq stop -h\nusage: jobq stop [-h] [--api-base-url Url] [--log-level str] &lt;ID&gt;\n\nTerminate the execution of a previously submitted job\n\npositional arguments:\n  &lt;ID&gt;\n\noptions:\n  -h, --help          show this help message and exit\n  --api-base-url Url  Base URL of the jobq API server (required)\n  --log-level str     Output log level (DEBUG, INFO, WARNING, ERROR, CRITICAL) (default: INFO)\n</code></pre> <p>The only required argument is the UID of the job to be terminated. You can easily obtain said UID by listing all previously submitted jobs via <code>jobq list</code>. In such a listing, the UID of each job appears together with its name in the leftmost name column.</p>"},{"location":"cli/#listing-available-jobs","title":"Listing available jobs","text":"<p>As mentioned, to list all submitted jobs, use the <code>jobq list</code> command.</p> <pre><code>$ jobq list -h\nusage: jobq list [-h] [--api-base-url Url] [--log-level str] [--limit &lt;N&gt;] [--filter &lt;cond&gt;]\n\nList previously submitted jobs\n\noptions:\n  -h, --help          show this help message and exit\n  --api-base-url Url  Base URL of the jobq API server (required)\n  --log-level str     Output log level (DEBUG, INFO, WARNING, ERROR, CRITICAL) (default: INFO)\n  --limit &lt;N&gt;         Limit the listing to only a number of the most recent workloads.\n  --filter &lt;cond&gt;     Filter existing workloads by a condition of the form &lt;key&gt;=&lt;value&gt; (e.g. status='succeeded'). Can be supplied\n                      multiple times for multiple conditions.\n</code></pre> <p>The resulting table includes useful information about each job such as name and UID, the cluster queue it was admitted to, its execution status, and flags if something unexpected (e.g. pod failures or preemptions) happened during execution.</p>"},{"location":"cli/#querying-job-status-and-logs","title":"Querying job status and logs","text":"<p><code>jobq</code> contains two commands to obtain metadata and information on submitted jobs.</p> <p>To query a job's status, use the <code>jobq status</code> command.</p> <pre><code>$ jobq status -h\nusage: jobq status [-h] [--api-base-url Url] [--log-level str] &lt;ID&gt;\n\nQuery the status of a previously submitted job\n\npositional arguments:\n  &lt;ID&gt;\n\noptions:\n  -h, --help          show this help message and exit\n  --api-base-url Url  Base URL of the jobq API server (required)\n  --log-level str     Output log level (DEBUG, INFO, WARNING, ERROR, CRITICAL) (default: INFO)\n</code></pre> <p>Again, the job's unique identifier in the cluster is required. To obtain a job's identifier, use the <code>jobq list</code> command.</p> <p>To get information about the job execution, or to troubleshoot failing pods, you can access a job's logs with the <code>jobq logs</code> command.</p> <pre><code>$ jobq logs -h  \nusage: jobq logs [-h] [--api-base-url Url] [--log-level str] [-f] [--tail TAIL] &lt;ID&gt;\n\nGet logs for specified job\n\npositional arguments:\n  &lt;ID&gt;\n\noptions:\n  -h, --help          show this help message and exit\n  --api-base-url Url  Base URL of the jobq API server (required)\n  --log-level str     Output log level (DEBUG, INFO, WARNING, ERROR, CRITICAL) (default: INFO)\n  -f, --follow        Whether to stream logs\n  --tail TAIL         Lines of recent logs to display (default: -1, all lines)\n</code></pre> <p>You can obtain logs in two different modes, either as an ex-post log dump, or in real time via streaming. Streaming logs can be useful to follow a job's lifecycle. To stream logs, use the <code>-f</code> flag. This feature behaves almost the same as <code>kubectl logs -f</code> does, with a few noteworthy differences:</p> <ul> <li>The order in which already written logs (i.e., those that were written after the stream was requested) are rendered is likely not the same as for <code>kubectl logs -f</code>.</li> <li>By default, in a multi-pod scenario, meaning multiple pods belong to a job, all logs are prefixed with the pod name to provide visual distinction. This is equivalent to the <code>--prefix --all-pods</code> options in <code>kubectl logs</code>.</li> </ul> <p>To limit a log selection to a number of the most recently written logs, give the <code>--tail</code> option with the desired number of lines.</p>"},{"location":"quickstart/","title":"Jobq, workflow submission and scheduling","text":"<p>Jobq is a tool that aims to make it easy for you to create, submit and schedule workflows.</p> <p>To get teams shipping fast, we keep the definition of the workflows inside a familiar environment: Python. You wrap all your logic into a function that you then decorate with the <code>@job</code> decorator. In this decorator you will define the environment and hardware requirements.</p> <p>You then use the <code>jobq</code> CLI to submit the workflow, stop it, or retrieve logs.</p> <p>The <code>jobq</code> backed is built on top of Kubernetes and is installed in the cluster, orchestrates the workflow management, and interfaces to the client CLI calls.</p> <p>Let us walk through an example. The example expects a set-up cluster and API server.</p>"},{"location":"quickstart/#workflow-definition-in-your-python-files","title":"Workflow definition in your Python files","text":"<p>To restructure your Python script into a workflow that can be executed by <code>jobq</code> you need to reorganize your logic such that everything is called from one top level function. Then you decorate this function with the <code>jobq.job</code> decorator. The decorator takes two arguments, <code>image</code> and <code>options</code>. You use the <code>image</code> argument to submit <code>ImageOptions</code>, a wrapper specifying the image, that is the environment your code will execute in. The <code>ImageOptions</code> take a <code>spec</code>, that is a path to a <code>.yaml</code> or <code>Dockerfile</code> which outlines the environment creation, as well as the name and tag of the image.</p> <p>The other argument to the <code>job</code> decorator are <code>options</code>. Here you specify the desired resources using the <code>ResourceOptions</code> wrapper, can attach labels and specify the <code>SchedulingOptions</code>.</p> <p>A defined job looks similar to this</p> <pre><code># quickstart.py\nfrom pathlib import Path\nfrom jobq import ImageOptions, JobOptions, ResourceOptions, SchedulingOptions, job\n\n@job(\n    options=JobOptions(\n        labels={\"type\": \"hello-world@quickstart\"},\n        resources=ResourceOptions(memory='1Gi', cpu='1'),\n        scheduling=SchedulingOptions(\n            priority_class='background', queue_name=\"user-queue\"\n        ),\n        image=ImageOptions(\n            spec=Path('dockerfile/path/relative/to/job'),\n            name=\"quickstart/hello-world\",\n            tag=\"latest\"\n        )\n    )\n)\ndef quickstart():\n    print(\"Hello, World!\")\n</code></pre>"},{"location":"quickstart/#interface-with-your-workflows-using-the-jobq-cli","title":"Interface with your workflows using the <code>jobq</code> CLI","text":"<p>Now that we have the job defined let us execute it. You can execute the job via the CLI,<code>jobq submit quickstart.py</code>. This execution is locally, which may be useful for debugging and testing. However, you probably want to execute the job on the remote cluster. In this case you can add the <code>--mode kueue</code> flag to submit the workflow to the cluster queue (orchestrated by Kubernetes Kueue) like so: <code>jobq submit --mode kueue quickstart.py</code>.</p> <p>This returns the job id which we can use to fetch or stream the logs using <code>jobq logs &lt;job id&gt;</code>.</p>"},{"location":"quickstart/#setting-up-the-jobq-backend-and-api-server","title":"Setting up the <code>jobq</code> Backend and API server","text":"<p>In this quickstart guide we use Minikube to run a Kubernetes cluster locally.</p> <p>In case you want to deploy the <code>jobq</code> backend on your own cluster, follow the instructions here..</p> <p>Follow the  instructions  to install Minikube in the Minikube docs. You will also need a container or virtual machine manager like Docker. Then, open a terminal and start Minikube with <code>minikube start</code>.</p> <p>Next, you need to ensure that the registry add-on is enabled. Do so by running <code>minikube addons enable registry</code>. The registry is where the cluster saves the job images.</p>"},{"location":"concepts/_index/","title":"Concepts","text":"<p>This section covers the basic concepts behind jobq.</p> <p>It can help you:</p> <ul> <li>Understand the high-level architecture of jobq.</li> <li>Understand how jobq identifies jobs.</li> <li>Understand the lifecycle of a job, from its submission to its completion.</li> </ul>"},{"location":"concepts/architecture/","title":"Understanding the jobq architecture","text":"<p>The jobq high-level architecture consists of two major components:</p> <ol> <li>The client-side library, which is used to declare and submit jobs to a compute cluster.</li> <li>The server-side API, which serves as the interface between the client and the compute cluster.</li> </ol> <pre><code>architecture-beta\n    group api[Compute Cluster]\n\n    service jobq(server)[Jobq API] in api\n    service kueue(server)[Kueue] in api\n    service kubernetes(server)[Kubernetes API] in api\n    service ray(server)[Kuberay] in api\n\n    service client(server)[jobq Client]\n\n    jobq:R --&gt; L:kueue\n    jobq:B --&gt; T:kubernetes\n\n    kueue:R --&gt; L:ray\n    kueue:B --&gt; T:kubernetes\n\n    client:R --&gt; L:jobq</code></pre>"},{"location":"concepts/architecture/#client-side-library","title":"Client-side library","text":"<p>The client-side Python library provides a high-level interface for declaring and executing jobs, either locally or on a compute cluster. It is designed to be easy to use and to integrate with other Python libraries and frameworks.</p> <p>The library is responsible for:</p> <ul> <li>Providing a <code>@job</code> decorator to annotate Python functions as jobs.</li> <li>Configuring the container image build for a job (through a declarative configuration or explicit <code>Dockerfile</code>).</li> <li>Setting runtime parameters for a job (e.g., its resource requirements).</li> <li>Managing the lifecycle of jobs, including monitoring their status and logs through a command-line interface.</li> </ul> <p>The library is implemented as a Python package that can be installed using pip.</p>"},{"location":"concepts/architecture/#server-side-api","title":"Server-side API","text":"<p>The server-side API is a RESTful API that provides a low-level interface for managing jobs in a compute cluster.</p> <p>It builds on top of Kubernetes and the Kueue framework, which provides a high-level abstraction for managing workloads in a Kubernetes cluster (including queueing, priority-based scheduling, preemption, and resource management).</p> <p>Kueue itself can manage workloads of various types, such as Kubernetes <code>Jobs</code>, Kuberay <code>RayJobs</code>, among others.</p>"},{"location":"concepts/identifiers/","title":"Job Identifiers","text":""},{"location":"concepts/identifiers/#terminology","title":"Terminology","text":"<p>In order to understand how jobq identifies jobs, it is important to understand the conceptual components of a workload: A jobs is composed of an abstract definition of the workload (as a Kueue <code>Workload</code> custom resource) and a set of Kubernetes resources (for example a Kubernetes <code>Job</code>, or a custom resource like the Kuberay <code>RayJob</code>) that make up the executable part of the workload.</p> <p>At first these similar-sounding names can be confusing, so let's establish some terminology:</p> <ul> <li>A workload or job (lowercase \"w\"/\"j\") is a set of Kubernetes resources that make up the     executable portion of a job.</li> <li>A Workload (uppercase \"W\") refers to the Kueue <code>Workload</code> custom resource.</li> <li>A Job (uppercase \"J\") refers to the Kubernetes <code>batch/v1/Job</code> resource (one way how code can be submitted through jobq).</li> </ul> <p>Kueue handles the <code>Workload</code> and updates its status to reflect the current state of the workload.</p> <p></p>"},{"location":"concepts/identifiers/#identifying-workloads","title":"Identifying workloads","text":"<p>Every Workload (as managed by Kueue) carries by an automatically generated unique identifier (UID) as well as a human-readable name and namespace. Both these could serve as a unique identifier for a Workload. However, a name/namespace combination is not guaranteed to be unique over time (for example when deleting and recreating), whereas UIDs are. This makes UIDs a slightly better choice for identifying a given Workload resource.</p> <p>The concrete workload resource has the same identifiers, a UID and name/namespace combination.</p> <p>A given job references its associated Workload in a 1:1 fashion (through its <code>metadata.ownerReferences</code> field).</p> <p>This theoretically allows to identify a job in the cluster through two different identifiers:</p> <ul> <li>the UID of the (concrete) job resource.</li> <li>the UID of the (abstract) Workload resource.</li> </ul> <p>In practice, jobq always uses the UID of the concrete workload as the identifier for a job. All CLI operations return and accept the UID of the concrete workload.</p> <p>As an example, imagine the following resources in the cluster after submitting a job:</p> <pre><code>graph LR\nsubgraph \"Namespace example\"\ndirection LR\n  A[\"`Workload **job-example** &lt;pre&gt;uid-1&lt;/pre&gt;`\"] --&gt; B[\"`Job **example** &lt;pre&gt;uid-2&lt;/pre&gt;`\"] --&gt; C[Pod]\nend</code></pre> <p>If we want to query the logs of the job, we can do so by calling <code>jobq logs</code> with the UID of the concrete workload:</p> <pre><code>$ jobq logs uid-2\n[... log output ...]\n</code></pre>"},{"location":"concepts/lifecycle/","title":"Job Lifecycle","text":"<p>Since jobq builds on top of the Kueue job queuing system for scheduling, the lifecycle of a job is very similar to the lifecycle of a workload in Kueue.</p> <p>The remainder of this document uses the terms job and workload interchangeably.</p> <p>A workload roughly goes through three phases after its submission: queuing and scheduling, execution, and completion.</p>"},{"location":"concepts/lifecycle/#queueing-and-scheduling","title":"Queueing and scheduling","text":"<p>After its submission, a workload is in the <code>Submitted</code> state, where it competes with other workloads for available resource quotas. Once it is admitted to a cluster queue, it enters the <code>Pending</code> state, where Kueue will reserve a quota for it. Alternatively, if the selected local or cluster queue for the workload are stopped or do not exist, the workload will enter the <code>Inadmissible</code> state until this condition is resolved.</p>"},{"location":"concepts/lifecycle/#execution","title":"Execution","text":"<p>After all admission checks for the workload have passed, it enters the <code>Admitted</code> state, it is now eligible for execution by the cluster.</p>"},{"location":"concepts/lifecycle/#completion","title":"Completion","text":"<p>When the workload terminates successfully, it enters the terminal <code>Succeeded</code> state. If any unrecoverable error occurs during execution, the workload enters the terminal <code>Failed</code> state. This does not necessarily happen on the first abnormal termination of a pod, depending on the type of workload and other factors (such as the retry limit in a <code>batch/v1/Job</code>).</p> <p>A currently executing workload may be preempted by another workload (e.g., by a newly submitted workload with a higher priority). In this case, Kueue will terminate any pods associated with the preempted workload and either requeue it for later execution or evict it from the cluster queue.</p>"},{"location":"concepts/lifecycle/#state-diagram","title":"State Diagram","text":"<pre><code>stateDiagram-v2\n    direction LR\n    [*] --&gt; Submitted\n\n    Submitted --&gt; Pending: quotaReserved\n    Submitted --&gt; Inadmissible\n    Inadmissible --&gt; Submitted\n\n    Pending --&gt; Admitted: admitted\n\n    Admitted --&gt; Succeeded: success\n    Admitted --&gt; Failed: error\n\n    Admitted --&gt; Submitted: evicted\n    Admitted --&gt; Pending: requeued\n    Succeeded --&gt; [*]\n    Failed --&gt; [*]</code></pre>"},{"location":"guide/_index/","title":"How-to Guides","text":"<p>This section contains guides that show you how to perform specific tasks with jobq. They are grouped by intended audiences, such as users and administrators.</p> <p>Please also familiarize yourself with the concepts to understand the terminology used in the guides.</p>"},{"location":"guide/_index/#developers","title":"Developers","text":"<ul> <li>Choosing an execution mode for your job</li> </ul>"},{"location":"guide/_index/#administrators","title":"Administrators","text":"<ul> <li>Deploying the jobq server</li> </ul>"},{"location":"guide/declarative_containers/","title":"Declarative Container Configuration","text":"<p>jobq allows you to define your container image in a declarative YAML format instead of writing a Dockerfile.</p>"},{"location":"guide/declarative_containers/#yaml-structure","title":"YAML Structure","text":"<p>The YAML structure, for the most part, mirrors the structure of a Dockerfile. We only provide an abstraction around the dependencies map. Hence, the official Dockerfile reference may be helpful to understand the meaning of different options. </p> <p>A full example of a declarative YAML looks like this: <pre><code>build:\n  base_image: &lt;base_image&gt;\n  dependencies:\n    apt: [&lt;apt_packages&gt;]\n    pip: [&lt;pip_packages&gt;]\n  volumes:\n    - &lt;container_path&gt;\n  user:\n    name: &lt;username&gt;\n  config:\n    env:\n      &lt;env_var&gt;: &lt;value&gt;\n    arg:\n      &lt;build_arg&gt;: &lt;value&gt;\n    stopsignal: &lt;signal&gt;\n    shell: &lt;shell&gt;\n  meta:\n    labels:\n      &lt;label_key&gt;: &lt;label_value&gt;\n  workdir: &lt;working_directory&gt;\n  filesystem:\n    copy:\n      &lt;src&gt;: &lt;dest&gt;\n    add:\n      &lt;src&gt;: &lt;dest&gt;\n</code></pre> Let us walk through an example of each of the options.</p> <p>The YAML file uses a <code>build</code> key as the root, under which various aspects of the Docker image are defined.</p> <p>First, you have to first specify the base image of the Dockerfile, for example:</p> <pre><code>build:\n  base_image: python:3.12-slim\n</code></pre> <p>Then, you can define system level and Python dependencies. The system level dependencies require a Debian or Ubuntu derived base image to ensure the availability of <code>apt</code>.</p> <p>The Python dependencies can be regular package dependencies, but you can also supply requirements files by prefixing them with <code>-r</code> or <code>--requirement</code> as well as wheel, <code>.whl</code>, files in the build context and editable local installs with <code>-e</code>. The latter require that the source directory contains a <code>pyproject.toml</code>.</p> <p><pre><code>build:\n  dependencies:\n    apt: [curl, git]\n    pip: [attrs, pyyaml, test.whl, marker-package, -e ., -r requirements.txt]\n</code></pre> In order to make directories or files within the container mountable, they have to be declared at build time. </p> <p><pre><code>build:\n  volumes:\n    - /mountable/path\n</code></pre> You can also define user information for running the container. <pre><code>build:\n  user:\n    name: no_admin\n</code></pre> If applicable you can set specific configuration options such as secrets, build arguments, etc. You can supply the environment and build arguments either as a dictionary <pre><code>build:\n  config:\n    env:\n      var: secret\n    arg:\n      build_arg: config\n    stopsignal: 1\n    shell: sh\n</code></pre></p> <p>Or as a list <pre><code>build:\n  config:\n    env:\n      - var=secret\n    arg:\n      - build_arg=config\n</code></pre></p> <p>To control the execution environment in the container and during the build process, configure the working directory and filesystem. They can be submitted as a dictionary:  <pre><code>build:\n  workdir: /usr/src/\n  filesystem:\n    copy:\n      source: target\n    add:\n      source: target\n</code></pre> Or as a list of strings: <pre><code>build:\n  workdir: /usr/src/\n  filesystem:\n    copy:\n      - source=target\n    add:\n      - source=target\n</code></pre></p> <p>Lastly, you can add metadata as per your convenience. You can again supply them either as a dict:  <pre><code>build:\n  meta:\n    labels:\n      test: test\n</code></pre> Or as a list of key value pairs <pre><code>build:\n  meta:\n    labels:\n      - test=test\n</code></pre></p> <p>To use the container image, you have to add it in your <code>@job</code> decorator as a <code>spec</code>. <pre><code>from jobq.job import Job, JobOptions, ImageOptions\nfrom pathlib import Path\n\n@job(\n    options=JobOptions(...),\n    image=ImageOptions(\n        spec=Path(\"path/to/your/docker.yaml\"),\n        name=\"your-image-name\",\n        tag=\"your-tag\"\n    )\n)\ndef your_job_function():\n    pass\n</code></pre> Now you can submit a job with the jobq CLI. jobq will automatically generate a Dockerfile from your YAML configuration when building the image for your job. If you submit a Dockerfile directly, it will be used.</p>"},{"location":"guide/execution-modes/","title":"Choosing an execution mode for your job","text":""},{"location":"guide/execution-modes/#understanding-execution-modes","title":"Understanding execution modes","text":"<p>Jobq allows you to run your jobs in different execution modes (through the <code>jobq submit --mode</code> parameter), in some cases even without any changes to your code.</p> <p>Execution modes determine how your job is executed, where it runs, and how resources are managed. The choice of execution mode depends on your requirements, such as the scale of your job, the resources it needs, and the frameworks and libraries you are using in your code.</p> <p>For example, if you are running a small job that does not require any external dependencies, you can submit your job as a \"plain\" Kubernetes batch job. However, if you are performing large-scale machine learning training, you might want to use a Ray job to distribute your workload across multiple compute nodes.</p>"},{"location":"guide/execution-modes/#local-execution","title":"Local execution","text":"<p>The most basic execution mode is <code>local</code>, which runs your job as a Python function on the same machine where the jobq client is executed. This mode does not provide any of the benefits such as automatic resource management, but it is the fastest way to get started.</p> <p>As an additional benefit, since you are running your job locally, you can easily debug your code and test it on a small scale before scaling it up to a cluster-based execution mode. Breakpoints, logging, and other debugging tools work as expected in this mode.</p>"},{"location":"guide/execution-modes/#cluster-based-execution","title":"Cluster-based execution","text":"<p>The more advanced execution modes require a backend to run your job and a Kubernetes cluster where the job can be scheduled and executed. All Kubernetes-based execution modes are built on top of Kueue, a Kubernetes-native job scheduling system, and extend its underlying functionality.</p> <p>Currently, jobq supports two cluster-based execution modes:</p> <ul> <li>Kueue Mode: This mode runs your job as a Kubernetes built-in <code>batch/v1/Job</code>.</li> <li>Ray Job Mode: This mode runs your job in an ephemeral Ray cluster, which is automatically created and destroyed for each job.</li> </ul>"},{"location":"guide/execution-modes/#kubernetes-batch-jobs","title":"Kubernetes batch jobs","text":"<p>By default, Kubernetes batch jobs are submitted using the following default parameters:</p> <ul> <li>Job parallelism is set to 1</li> <li>Image pull policy is set to <code>IfNotPresent</code></li> <li>Backoff limit set to 6 (exponential backoff applies to retried jobs)</li> <li>Resource requests are applied as <code>limits == requests</code></li> </ul>"},{"location":"guide/execution-modes/#ray-jobs","title":"Ray jobs","text":"<p>The default options for Ray jobs submitted by jobq are as follows:</p> <ul> <li>Single head node, no worker nodes</li> <li>Job clusters are shut down automatically after job finishes</li> <li>Job image is used for worker nodes and job submission pod</li> <li>Image pull policy is set to <code>IfNotPresent</code></li> <li>Resource requests are applied as <code>limits == requests</code></li> </ul>"},{"location":"guide/execution-modes/#choosing-an-execution-mode","title":"Choosing an execution mode","text":"<p>When choosing an execution mode for your job, consider the following factors:</p> <ul> <li>Integration with other code: If you are using a specific framework or library that requires a specific execution mode, you may need to choose an execution mode that best supports that framework or library (e.g., submit Ray jobs as such, although they could also be submitted as a plain job which spins up an ephemeral one-node Ray cluster.).</li> <li>Resource requirements: Different execution modes have different resource requirements. For example, Ray jobs require more resources than Kubernetes batch jobs due to the overhead of running the components Ray control plane.</li> <li>Scaling needs: If you need to scale your job across multiple nodes, you may need to choose an execution mode that supports distributed computing, such as Ray jobs. In addition, frameworks like Ray provide support for autoscaling based on resource demand, which can help you scale your cluster dynamically based on the workload.</li> <li>Runtime observability: If you need to introspect the runtime environment of your job, such as the number of nodes, CPU and memory usage, and other metrics, you may need to choose an execution mode that provides this information. For example, Ray exposes a variety of metrics that can be used to monitor the performance of a Ray cluster and jobs submitted to it.</li> </ul> <p>As a general guideline, you can start with local execution mode for development and testing, and then switch to a cluster-based execution mode for production workloads. Local execution allows you to easily debug your code and test it on a small scale, while cluster-based execution modes provide better resource management and scalability for large-scale jobs, especially when working in a team of multiple developers.</p>"},{"location":"guide/server-deployment/","title":"How to deploy a jobq server","text":"<p>This guide will walk you through the steps to deploy a jobq server to an existing Kubernetes cluster.</p> <p>The following steps assume you already have a Kubernetes cluster set up and running. If you need guidance on how to do this, please refer to the Kubernetes documentation and check out Minikube if you want to try out a local Kubernetes cluster.</p>"},{"location":"guide/server-deployment/#prerequisites","title":"Prerequisites","text":"<p>Before you can deploy a jobq server, you need to have the tools following installed on your machine:</p> <ul> <li>kubectl</li> <li>Helm</li> </ul>"},{"location":"guide/server-deployment/#kueue","title":"Kueue","text":"<p>jobq requires Kueue to be installed in the same Kubernetes cluster as a prerequisite. Please refer to the Kueue documentation for more information on how to install Kueue.</p> <p>If you want to install Kueue with default settings, you can do so by running the following command (optionally replacing <code>latest</code> with the desired version):</p> <pre><code>kubectl apply --server-side -f \\\n    https://github.com/kubernetes-sigs/kueue/releases/latest/download/manifests.yaml\n</code></pre> <p>You also need to set up a few additional resources for Kueue to work properly:</p> <ul> <li>a cluster queue (<code>ClusterQueue</code> CRD)</li> <li>a namespaced local queue (<code>LocalQueue</code> CRD)</li> <li>a resource flavor (<code>ResourceFlavor</code> CRD)</li> <li>optionally, one or more priority classes (<code>WorkloadPriorityClass</code> CRD)</li> </ul> <p>For a quick start, the jobq repository contains a YAML file with a cluster queue <code>cluster-queue</code> with a default resource flavor <code>default-flavor</code>, a local queue <code>user-queue</code> and three priority classes <code>background</code>, <code>dev</code>, and <code>production</code>:</p> <pre><code>$ kubectl apply --server-side -f \\\n    https://raw.githubusercontent.com/aai-institute/jobq/refs/heads/main/client/single-clusterqueue-setup.yaml\n</code></pre>"},{"location":"guide/server-deployment/#kuberay-optional","title":"Kuberay (optional)","text":"<p>If you want to submit Ray jobs to your Kubernetes cluster, you need to install the Ray operator as well:</p> <pre><code>$ helm repo add kuberay https://ray-project.github.io/kuberay-helm/\n$ helm install --wait kuberay-operator kuberay/kuberay-operator\n</code></pre>"},{"location":"guide/server-deployment/#deployment-with-helm-recommended","title":"Deployment with Helm (recommended)","text":"<p>After settings up the prerequisites, you can use the following command to deploy the jobq server to your Kubernetes cluster:</p> <pre><code>$ helm repo add jobq https://aai-institute.github.io/jobq\n$ helm install --wait jobq jobq/jobq-server\n</code></pre> <p>This will install the jobq server in the currently active namespace. You can change the namespace by passing the <code>--namespace</code> flag to the <code>helm install</code> command.</p> <p>Please see the README of the jobq Helm chart for more information on how to configure the jobq server.</p> <p>Note</p> <p>Currently, the jobq server will only handle workloads in the namespace it is installed in. If you want to watch workloads in multiple namespaces, you will need to install the jobq server in each of those namespaces.</p>"},{"location":"guide/server-deployment/#running-in-a-docker-container","title":"Running in a Docker container","text":"<p>While running the jobq server inside the Kubernetes cluster is the recommended setup, you can also run it in a Docker container:</p> <pre><code>$ docker run \\\n    -v ${KUBECONFIG:-~/.kube/config}:/secrets/kubeconfig \\\n    -e KUBECONFIG=/secrets/kubeconfig \\\n    -p 8000:8000 \\\n    ghcr.io/aai-institute/jobq-server:main\n</code></pre> <p>This will make the jobq API available at <code>http://localhost:8000</code>.</p> <p>Note that you will need to make sure that the container has network access to the Kubernetes API server and credentials to access it (e.g., by mounting the <code>~/.kube/config</code> file and setting the <code>KUBECONFIG</code> environment variable).</p> <p>To prevent path errors related to CA certificates in the Kubeconfig file, you may want to generate a flattened version of the file to use for the mount:</p> <pre><code>$ kubectl config view --flatten &gt; /tmp/kubeconfig\n</code></pre> <p>If you are using Minikube or another local Kubernetes cluster, you may want to spawn the jobq container in host networking mode to allow it to access the Kubernetes API server:</p> <pre><code>$ docker run \\\n    --network host \\\n    -v ${KUBECONFIG:-~/.kube/config}:/secrets/kubeconfig \\\n    -e KUBECONFIG=/secrets/kubeconfig \\\n    ghcr.io/aai-institute/jobq-server:main\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>cli<ul> <li>commands<ul> <li>list</li> <li>logs</li> <li>status</li> <li>stop</li> <li>submit</li> </ul> </li> <li>parser</li> <li>types</li> <li>util</li> </ul> </li> <li>jobq<ul> <li>assembler<ul> <li>config</li> <li>renderers</li> </ul> </li> <li>execute</li> <li>image</li> <li>job</li> <li>submission_context</li> <li>types</li> <li>utils<ul> <li>helpers</li> <li>math</li> <li>processes</li> </ul> </li> </ul> </li> <li>openapi_client<ul> <li>api<ul> <li>job_management_api</li> </ul> </li> <li>api_client</li> <li>api_response</li> <li>configuration</li> <li>exceptions</li> <li>models<ul> <li>create_job_model</li> <li>execution_mode</li> <li>http_validation_error</li> <li>job_options</li> <li>job_status</li> <li>list_workload_model</li> <li>resource_options</li> <li>scheduling_options</li> <li>validation_error</li> <li>validation_error_loc_inner</li> <li>workload_admission</li> <li>workload_identifier</li> <li>workload_metadata</li> <li>workload_spec</li> <li>workload_status</li> </ul> </li> <li>rest</li> </ul> </li> </ul>"},{"location":"reference/cli/","title":"cli","text":""},{"location":"reference/cli/#cli.main","title":"main","text":"<pre><code>main(**kwargs: str) -&gt; None\n</code></pre> <p>CLI entrypoint for job submission</p> Source code in <code>client/src/cli/__init__.py</code> <pre><code>def main(**kwargs: str) -&gt; None:\n    \"\"\"CLI entrypoint for job submission\"\"\"\n\n    logging.basicConfig(level=logging.DEBUG)\n    logging.getLogger(\"urllib3.connectionpool\").setLevel(logging.INFO)\n\n    try:\n        # Integrate CLI settings into the base parser used by all CLI subcommands and load settings\n        # https://docs.pydantic.dev/latest/concepts/pydantic_settings/#integrating-with-existing-parsers\n\n        # Note that the settings will be made available on the subcommands, rather than the root command.\n        # Thus, one cannot invoke the CLI like so:\n        #   jobq --cli-option=... &lt;subcommand&gt;\n\n        cli.parser.init()\n        cli_settings = CliSettingsSource(\n            Settings,\n            root_parser=cli.parser.parser,\n            cli_exit_on_error=False,\n            cli_parse_args=None,\n            cli_hide_none_type=True,\n        )\n        parser = cli.parser.build_root_parser()\n        func_args = parser.parse_args(kwargs.get(\"args\"))\n\n        try:\n            settings = Settings(\n                _cli_settings_source=cli_settings(parsed_args=func_args)\n            )\n            _configure_logging(settings)\n            logging.debug(f\"settings: {settings}\")\n        except pydantic.ValidationError as e:\n            print(\"Invalid settings detected:\", file=sys.stderr)\n            for error in e.errors():\n                print(\n                    f\"  - {error['loc'][0]}: {error['msg']} (got {error['input']!r})\",\n                    file=sys.stderr,\n                )\n            sys.exit(1)\n\n        # this is the case of no command, but also no existing action\n        # (like -h or --version) -&gt; user error\n        if not hasattr(func_args, \"func\"):\n            raise ValueError(\"no subcommand specified\")\n        func_args.func(func_args, settings=settings)\n        sys.exit(0)\n    except Exception as e:\n        print(f\"error: {e}\", file=sys.stderr)\n        # FIXME: Exit with more nuanced error codes\n        sys.exit(1)\n</code></pre>"},{"location":"reference/cli/#modules","title":"Modules","text":""},{"location":"reference/cli/#commands","title":"commands","text":""},{"location":"reference/cli/#parser","title":"parser","text":""},{"location":"reference/cli/#types","title":"types","text":""},{"location":"reference/cli/#util","title":"util","text":""},{"location":"reference/cli/#assembler","title":"assembler","text":""},{"location":"reference/cli/#execute","title":"execute","text":""},{"location":"reference/cli/#image","title":"image","text":""},{"location":"reference/cli/#job","title":"job","text":""},{"location":"reference/cli/#submission_context","title":"submission_context","text":""},{"location":"reference/cli/#types_1","title":"types","text":""},{"location":"reference/cli/#utils","title":"utils","text":""},{"location":"reference/cli/#api","title":"api","text":""},{"location":"reference/cli/#api_client","title":"api_client","text":"<p>the jobq cluster workflow management tool backend</p>"},{"location":"reference/cli/#api_response","title":"api_response","text":"<p>API response object.</p>"},{"location":"reference/cli/#configuration","title":"configuration","text":"<p>the jobq cluster workflow management tool backend</p>"},{"location":"reference/cli/#exceptions","title":"exceptions","text":"<p>the jobq cluster workflow management tool backend</p>"},{"location":"reference/cli/#models","title":"models","text":"<p>the jobq cluster workflow management tool backend</p>"},{"location":"reference/cli/#rest","title":"rest","text":"<p>the jobq cluster workflow management tool backend</p>"},{"location":"reference/cli/parser/","title":"parser","text":""},{"location":"reference/cli/types/","title":"types","text":""},{"location":"reference/cli/util/","title":"util","text":""},{"location":"reference/cli/commands/","title":"commands","text":""},{"location":"reference/cli/commands/list/","title":"list","text":""},{"location":"reference/cli/commands/logs/","title":"logs","text":""},{"location":"reference/cli/commands/status/","title":"status","text":""},{"location":"reference/cli/commands/stop/","title":"stop","text":""},{"location":"reference/cli/commands/submit/","title":"submit","text":""},{"location":"reference/jobq/","title":"jobq","text":""},{"location":"reference/jobq/#jobq.ImageOptions","title":"ImageOptions","text":"<p>               Bases: <code>BaseModel</code></p> <p>Options to configure the build of the Docker image used to execute a <code>jobq.Job</code> in the cluster.</p> <p>Either the <code>spec</code> argument or the <code>dockerfile</code> argument must be given, and if given, <code>spec</code> must be an existing file containing valid YAML.</p> Source code in <code>client/src/jobq/job.py</code> <pre><code>class ImageOptions(BaseModel):\n    \"\"\"\n    Options to configure the build of the Docker image used to execute a\n    ``jobq.Job`` in the cluster.\n\n    Either the ``spec`` argument or the ``dockerfile`` argument must be\n    given, and if given, ``spec`` must be an existing file containing\n    valid YAML.\n    \"\"\"\n\n    name: StrictStr | None = None\n    \"\"\"The name under which the image should be pushed to the cluster image registry.\"\"\"\n    tag: StrictStr | None = \"latest\"\n    \"\"\"The tag identifier to use for the newly built Docker image.\"\"\"\n    spec: Path | None = None\n    \"\"\"Path to a YAML spec file describing a Docker image build.\"\"\"\n    dockerfile: Path | None = None\n    \"\"\"Path to an existing Dockerfile to use for the image build.\"\"\"\n\n    @property\n    def build_mode(self) -&gt; BuildMode:\n        if self.spec is not None:\n            return BuildMode.YAML\n        elif self.dockerfile is not None:\n            return BuildMode.DOCKERFILE\n        else:\n            raise ValueError(\n                \"error building image: either YAML spec or Dockerfile must be set.\"\n            )\n\n    def model_post_init(self, /, __context: Any) -&gt; None:\n        def _is_yaml(path: AnyPath) -&gt; bool:\n            filename = Path(path).name\n            return filename.endswith((\".yaml\", \".yml\"))\n\n        if self.spec is None and self.dockerfile is None:\n            raise ValueError(\"Must specify either image spec or Dockerfile\")\n\n        if self.spec is not None and self.dockerfile is not None:\n            raise ValueError(\"Cannot specify both image spec and Dockerfile\")\n\n        if self.spec is not None and not _is_yaml(self.spec):\n            raise ValueError(f\"Container image spec is not a YAML file: {self.spec}\")\n</code></pre>"},{"location":"reference/jobq/#jobq.ImageOptions.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: StrictStr | None = None\n</code></pre> <p>The name under which the image should be pushed to the cluster image registry.</p>"},{"location":"reference/jobq/#jobq.ImageOptions.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: StrictStr | None = 'latest'\n</code></pre> <p>The tag identifier to use for the newly built Docker image.</p>"},{"location":"reference/jobq/#jobq.ImageOptions.spec","title":"spec  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>spec: Path | None = None\n</code></pre> <p>Path to a YAML spec file describing a Docker image build.</p>"},{"location":"reference/jobq/#jobq.ImageOptions.dockerfile","title":"dockerfile  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dockerfile: Path | None = None\n</code></pre> <p>Path to an existing Dockerfile to use for the image build.</p>"},{"location":"reference/jobq/#jobq.Job","title":"Job","text":"<p>               Bases: <code>Generic[P, T]</code></p> Source code in <code>client/src/jobq/job.py</code> <pre><code>class Job(Generic[P, T]):\n    def __init__(\n        self,\n        func: Callable[P, T],\n        *,\n        options: JobOptions | None = None,\n        image: ImageOptions | None = None,\n        build_context: Path | None = None,\n    ) -&gt; None:\n        functools.update_wrapper(self, func)\n        self._func = func\n        self.options = options\n        self.image = image\n\n        if (module := inspect.getmodule(self._func)) is None:\n            raise ValueError(\"Cannot derive module for Job function.\")\n\n        job_file = Path(str(module.__file__))\n        self._name = self._func.__name__\n        self.build_context = (\n            build_context\n            if build_context is not None\n            else self._resolve_build_context(job_file)\n        )\n        self._file = job_file.relative_to(self.build_context)\n        self.validate()\n\n    def _resolve_build_context(self, job_file: Path) -&gt; Path:\n        max_depth = 15\n        build_context = job_file.resolve()\n        for _ in range(max_depth):\n            if self._is_project_root(build_context):\n                break\n            build_context = build_context.parent\n        else:\n            raise ValueError(\n                f\"Could not resolve build context from job file {self._file}, traversed {max_depth} up.\"\n            )\n        return build_context\n\n    @classmethod\n    def _is_project_root(cls, path: Path) -&gt; bool:\n        indicators = [\n            \".git\",\n            \"pyproject.toml\",\n            \"setup.py\",\n        ]\n        return any((path / indicator).exists() for indicator in indicators)\n\n    @property\n    def name(self) -&gt; str:\n        return self._name\n\n    @property\n    def file(self) -&gt; str:\n        return str(self._file)\n\n    def __call__(self, *args: P.args, **kwargs: P.kwargs) -&gt; T:\n        return self._func(*args, **kwargs)\n\n    def _resolve_path_in_build_context(self, path: Path) -&gt; Path:\n        if self.build_context is None:\n            raise ValueError(\"Build context not resolved\")\n\n        resolved_path = self.build_context / path\n\n        if not resolved_path.is_file():\n            raise FileNotFoundError(\n                f\"Could not resolve path {path!r}. Path must be relative to resolved build context, {self.build_context!r}\",\n                resolved_path,\n            )\n\n        return resolved_path\n\n    def _render_dockerfile(self) -&gt; str:\n        \"\"\"Render the job's Dockerfile from a YAML spec.\"\"\"\n\n        if not (self.image):\n            raise ValueError(\"Container image options must be specified\")\n\n        if not self.image.spec:\n            raise ValueError(\"Container image spec must be specified\")\n\n        image_spec = self._resolve_path_in_build_context(self.image.spec)\n\n        image_cfg = config.load_config(image_spec)\n\n        renderers = [cls(image_cfg) for cls in RENDERERS if cls.accepts(image_cfg)]\n        dockerfile_content = \"\"\n        for r in renderers:\n            dockerfile_content += r.render() + \"\\n\"\n        return dockerfile_content\n\n    def validate(self) -&gt; None:\n        if self.options:\n            validate_labels(self.options.labels)\n\n    def build_image(\n        self,\n        push: bool = False,\n    ) -&gt; Image | None:\n        if not self.image:\n            raise ValueError(\"Need image options to build image\")\n        opts = self.image\n\n        tag = f\"{opts.name or self.name}:{opts.tag}\"\n\n        logging.info(f\"Building container image: {tag!r}\")\n\n        build_cmd = [\"docker\", \"build\", \"-t\", tag]\n        labels = self.options.labels if self.options else {}\n        build_cmd.extend([f\"--label={k}={v}\" for k, v in labels.items()])\n\n        exit_code: int = -1\n        if opts.build_mode == BuildMode.YAML:\n            yaml = self._render_dockerfile()\n            with io.StringIO(yaml) as dockerfile:\n                build_cmd.extend([\"-f-\", f\"{self.build_context.absolute()}\"])\n                exit_code, _, _, _ = run_command(\n                    shlex.join(build_cmd),\n                    stdin=dockerfile,\n                    verbose=True,\n                )\n        elif opts.build_mode == BuildMode.DOCKERFILE:\n            if not opts.dockerfile:\n                raise ValueError(\"Dockerfile path must be specified\")\n            build_cmd.extend([\n                \"-f\",\n                f\"{self._resolve_path_in_build_context(opts.dockerfile)}\",\n                f\"{self.build_context.absolute()}\",\n            ])\n            exit_code, _, _, _ = run_command(\n                shlex.join(build_cmd),\n                verbose=True,\n            )\n\n        if exit_code == 0:\n            if push:\n                logging.info(\"Pushing container image to remote registry\")\n                exit_code, _, _, _ = run_command(\n                    f\"docker push {tag}\",\n                    verbose=True,\n                )\n                if exit_code != 0:\n                    return None\n\n            return Image(tag)\n        else:\n            return None\n</code></pre>"},{"location":"reference/jobq/#jobq.JobOptions","title":"JobOptions","text":"<p>               Bases: <code>JsonSerializable</code>, <code>DictSerializable</code>, <code>BaseModel</code></p> <p>Options for customizing a Kubernetes job definition from a Python function.</p> Source code in <code>client/src/jobq/job.py</code> <pre><code>class JobOptions(JsonSerializable, DictSerializable, BaseModel):\n    \"\"\"\n    Options for customizing a Kubernetes job definition from a Python function.\n    \"\"\"\n\n    resources: ResourceOptions | None = None\n    \"\"\"Compute resources to request for the job.\"\"\"\n    scheduling: SchedulingOptions\n    \"\"\"Information about the Kueue cluster queue, and job priority.\"\"\"\n    labels: dict[str, StrictStr] = Field(default_factory=dict)\n    \"\"\"Kubernetes labels to attach to the resulting Kueue workload.\"\"\"\n    __properties: ClassVar[list[str]] = [\"resources\", \"scheduling\", \"labels\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/jobq/#jobq.JobOptions.resources","title":"resources  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resources: ResourceOptions | None = None\n</code></pre> <p>Compute resources to request for the job.</p>"},{"location":"reference/jobq/#jobq.JobOptions.scheduling","title":"scheduling  <code>instance-attribute</code>","text":"<pre><code>scheduling: SchedulingOptions\n</code></pre> <p>Information about the Kueue cluster queue, and job priority.</p>"},{"location":"reference/jobq/#jobq.JobOptions.labels","title":"labels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>labels: dict[str, StrictStr] = Field(default_factory=dict)\n</code></pre> <p>Kubernetes labels to attach to the resulting Kueue workload.</p>"},{"location":"reference/jobq/#jobq.JobOptions.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>client/src/jobq/job.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/jobq/#jobq.ResourceOptions","title":"ResourceOptions","text":"<p>               Bases: <code>JsonSerializable</code>, <code>DictSerializable</code>, <code>BaseModel</code></p> <p>Options for requesting cluster compute resources for a <code>jobq.Job</code>.</p> <p>Memory and CPU values need to be given as <code>&lt;num&gt; &lt;prefix&gt;</code>, where num is a floating point number, and prefix is one of the following SI metric prefixes:     * <code>m, k, M, G, T</code> (base 10)     * <code>Ki, Mi, Gi, Ti</code> (base 2).</p> Source code in <code>client/src/jobq/job.py</code> <pre><code>class ResourceOptions(JsonSerializable, DictSerializable, BaseModel):\n    \"\"\"\n    Options for requesting cluster compute resources for a ``jobq.Job``.\n\n    Memory and CPU values need to be given as ``&lt;num&gt; &lt;prefix&gt;``, where num\n    is a floating point number, and prefix is one of the following SI metric\n    prefixes:\n        * ``m, k, M, G, T`` (base 10)\n        * ``Ki, Mi, Gi, Ti`` (base 2).\n    \"\"\"\n\n    memory: StrictStr | None = None\n    \"\"\"Memory required for pods hosting the job.\"\"\"\n    cpu: StrictStr | None = None\n    \"\"\"CPUs to request for pods hosting the job.\"\"\"\n    gpu: StrictInt | None = None\n    \"\"\"GPUs to request for pods hosting the job.\"\"\"\n    __properties: ClassVar[list[str]] = [\"memory\", \"cpu\", \"gpu\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_docker(self) -&gt; DockerResourceOptions:\n        from docker.types import DeviceRequest\n\n        options: DockerResourceOptions = {\n            \"mem_limit\": str(int(to_rational(self.memory))) if self.memory else None,\n            \"nano_cpus\": int(to_rational(self.cpu) * 10**9) if self.cpu else None,\n            \"device_requests\": (\n                [\n                    DeviceRequest(\n                        capabilities=[[\"gpu\"]],\n                        count=self.gpu,\n                    )\n                ]\n                if self.gpu\n                else None\n            ),\n        }\n        return remove_none_values(options)\n\n    def to_kubernetes(\n        self, kind: K8sResourceKind = K8sResourceKind.REQUESTS\n    ) -&gt; K8sResourceOptions:\n        # TODO: Currently kind is not accessed and the logic for \"request\" and \"limit\" is the same.\n        # Down the road we have to decide if we want to keep it that way (and get rid of the distinction and arguments),\n        # or if it makes sense for us to distinguish both cases.\n        options: K8sResourceOptions = {\n            \"cpu\": self.cpu or None,\n            \"memory\": self.memory or None,\n            \"nvidia.com/gpu\": self.gpu or None,\n        }\n        return remove_none_values(options)\n\n    def to_ray(self) -&gt; RayResourceOptions:\n        options: RayResourceOptions = {\n            \"entrypoint_memory\": int(to_rational(self.memory)) if self.memory else None,\n            \"entrypoint_num_cpus\": int(to_rational(self.cpu)) if self.cpu else None,\n            \"entrypoint_num_gpus\": self.gpu or None,\n        }\n        return remove_none_values(options)\n</code></pre>"},{"location":"reference/jobq/#jobq.ResourceOptions.memory","title":"memory  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>memory: StrictStr | None = None\n</code></pre> <p>Memory required for pods hosting the job.</p>"},{"location":"reference/jobq/#jobq.ResourceOptions.cpu","title":"cpu  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cpu: StrictStr | None = None\n</code></pre> <p>CPUs to request for pods hosting the job.</p>"},{"location":"reference/jobq/#jobq.ResourceOptions.gpu","title":"gpu  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gpu: StrictInt | None = None\n</code></pre> <p>GPUs to request for pods hosting the job.</p>"},{"location":"reference/jobq/#jobq.ResourceOptions.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>client/src/jobq/job.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/jobq/#jobq.SchedulingOptions","title":"SchedulingOptions","text":"<p>               Bases: <code>BaseModel</code></p> <p>Options configuring a <code>jobq.Job</code>'s priority in the cluster, and the Kueue cluster queue name the job should be submitted to.</p> Source code in <code>client/src/jobq/job.py</code> <pre><code>class SchedulingOptions(BaseModel):\n    \"\"\"\n    Options configuring a ``jobq.Job``'s priority in the cluster, and\n    the Kueue cluster queue name the job should be submitted to.\n    \"\"\"\n\n    priority_class: StrictStr | None = None\n    \"\"\"Name of a Kueue priority class to use for the job. Must exist in the target cluster.\"\"\"\n    queue_name: StrictStr\n    \"\"\"The Kueue cluster queue name to submit the job to. Must refer to an existing queue\n     in the cluster, otherwise the resulting workload will be marked inadmissible.\"\"\"\n    __properties: ClassVar[list[str]] = [\"priority_class\", \"queue_name\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of SchedulingOptions from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: AbstractSet[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        # set to None if priority_class (nullable) is None\n        # and model_fields_set contains the field\n        if self.priority_class is None and \"priority_class\" in self.model_fields_set:\n            _dict[\"priority_class\"] = None\n\n        # set to None if queue_name (nullable) is None\n        # and model_fields_set contains the field\n        if self.queue_name is None and \"queue_name\" in self.model_fields_set:\n            _dict[\"queue_name\"] = None\n\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of SchedulingOptions from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"priority_class\": obj.get(\"priority_class\"),\n            \"queue_name\": obj.get(\"queue_name\"),\n        })\n        return _obj\n</code></pre>"},{"location":"reference/jobq/#jobq.SchedulingOptions.priority_class","title":"priority_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority_class: StrictStr | None = None\n</code></pre> <p>Name of a Kueue priority class to use for the job. Must exist in the target cluster.</p>"},{"location":"reference/jobq/#jobq.SchedulingOptions.queue_name","title":"queue_name  <code>instance-attribute</code>","text":"<pre><code>queue_name: StrictStr\n</code></pre> <p>The Kueue cluster queue name to submit the job to. Must refer to an existing queue in the cluster, otherwise the resulting workload will be marked inadmissible.</p>"},{"location":"reference/jobq/#jobq.SchedulingOptions.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>client/src/jobq/job.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/jobq/#jobq.SchedulingOptions.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>client/src/jobq/job.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/jobq/#jobq.SchedulingOptions.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of SchedulingOptions from a JSON string</p> Source code in <code>client/src/jobq/job.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of SchedulingOptions from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/jobq/#jobq.SchedulingOptions.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>client/src/jobq/job.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: AbstractSet[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    # set to None if priority_class (nullable) is None\n    # and model_fields_set contains the field\n    if self.priority_class is None and \"priority_class\" in self.model_fields_set:\n        _dict[\"priority_class\"] = None\n\n    # set to None if queue_name (nullable) is None\n    # and model_fields_set contains the field\n    if self.queue_name is None and \"queue_name\" in self.model_fields_set:\n        _dict[\"queue_name\"] = None\n\n    return _dict\n</code></pre>"},{"location":"reference/jobq/#jobq.SchedulingOptions.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of SchedulingOptions from a dict</p> Source code in <code>client/src/jobq/job.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of SchedulingOptions from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"priority_class\": obj.get(\"priority_class\"),\n        \"queue_name\": obj.get(\"queue_name\"),\n    })\n    return _obj\n</code></pre>"},{"location":"reference/jobq/execute/","title":"execute","text":""},{"location":"reference/jobq/image/","title":"image","text":""},{"location":"reference/jobq/job/","title":"job","text":""},{"location":"reference/jobq/job/#jobq.job.ImageOptions","title":"ImageOptions","text":"<p>               Bases: <code>BaseModel</code></p> <p>Options to configure the build of the Docker image used to execute a <code>jobq.Job</code> in the cluster.</p> <p>Either the <code>spec</code> argument or the <code>dockerfile</code> argument must be given, and if given, <code>spec</code> must be an existing file containing valid YAML.</p> Source code in <code>client/src/jobq/job.py</code> <pre><code>class ImageOptions(BaseModel):\n    \"\"\"\n    Options to configure the build of the Docker image used to execute a\n    ``jobq.Job`` in the cluster.\n\n    Either the ``spec`` argument or the ``dockerfile`` argument must be\n    given, and if given, ``spec`` must be an existing file containing\n    valid YAML.\n    \"\"\"\n\n    name: StrictStr | None = None\n    \"\"\"The name under which the image should be pushed to the cluster image registry.\"\"\"\n    tag: StrictStr | None = \"latest\"\n    \"\"\"The tag identifier to use for the newly built Docker image.\"\"\"\n    spec: Path | None = None\n    \"\"\"Path to a YAML spec file describing a Docker image build.\"\"\"\n    dockerfile: Path | None = None\n    \"\"\"Path to an existing Dockerfile to use for the image build.\"\"\"\n\n    @property\n    def build_mode(self) -&gt; BuildMode:\n        if self.spec is not None:\n            return BuildMode.YAML\n        elif self.dockerfile is not None:\n            return BuildMode.DOCKERFILE\n        else:\n            raise ValueError(\n                \"error building image: either YAML spec or Dockerfile must be set.\"\n            )\n\n    def model_post_init(self, /, __context: Any) -&gt; None:\n        def _is_yaml(path: AnyPath) -&gt; bool:\n            filename = Path(path).name\n            return filename.endswith((\".yaml\", \".yml\"))\n\n        if self.spec is None and self.dockerfile is None:\n            raise ValueError(\"Must specify either image spec or Dockerfile\")\n\n        if self.spec is not None and self.dockerfile is not None:\n            raise ValueError(\"Cannot specify both image spec and Dockerfile\")\n\n        if self.spec is not None and not _is_yaml(self.spec):\n            raise ValueError(f\"Container image spec is not a YAML file: {self.spec}\")\n</code></pre>"},{"location":"reference/jobq/job/#jobq.job.ImageOptions.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: StrictStr | None = None\n</code></pre> <p>The name under which the image should be pushed to the cluster image registry.</p>"},{"location":"reference/jobq/job/#jobq.job.ImageOptions.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: StrictStr | None = 'latest'\n</code></pre> <p>The tag identifier to use for the newly built Docker image.</p>"},{"location":"reference/jobq/job/#jobq.job.ImageOptions.spec","title":"spec  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>spec: Path | None = None\n</code></pre> <p>Path to a YAML spec file describing a Docker image build.</p>"},{"location":"reference/jobq/job/#jobq.job.ImageOptions.dockerfile","title":"dockerfile  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dockerfile: Path | None = None\n</code></pre> <p>Path to an existing Dockerfile to use for the image build.</p>"},{"location":"reference/jobq/job/#jobq.job.ResourceOptions","title":"ResourceOptions","text":"<p>               Bases: <code>JsonSerializable</code>, <code>DictSerializable</code>, <code>BaseModel</code></p> <p>Options for requesting cluster compute resources for a <code>jobq.Job</code>.</p> <p>Memory and CPU values need to be given as <code>&lt;num&gt; &lt;prefix&gt;</code>, where num is a floating point number, and prefix is one of the following SI metric prefixes:     * <code>m, k, M, G, T</code> (base 10)     * <code>Ki, Mi, Gi, Ti</code> (base 2).</p> Source code in <code>client/src/jobq/job.py</code> <pre><code>class ResourceOptions(JsonSerializable, DictSerializable, BaseModel):\n    \"\"\"\n    Options for requesting cluster compute resources for a ``jobq.Job``.\n\n    Memory and CPU values need to be given as ``&lt;num&gt; &lt;prefix&gt;``, where num\n    is a floating point number, and prefix is one of the following SI metric\n    prefixes:\n        * ``m, k, M, G, T`` (base 10)\n        * ``Ki, Mi, Gi, Ti`` (base 2).\n    \"\"\"\n\n    memory: StrictStr | None = None\n    \"\"\"Memory required for pods hosting the job.\"\"\"\n    cpu: StrictStr | None = None\n    \"\"\"CPUs to request for pods hosting the job.\"\"\"\n    gpu: StrictInt | None = None\n    \"\"\"GPUs to request for pods hosting the job.\"\"\"\n    __properties: ClassVar[list[str]] = [\"memory\", \"cpu\", \"gpu\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_docker(self) -&gt; DockerResourceOptions:\n        from docker.types import DeviceRequest\n\n        options: DockerResourceOptions = {\n            \"mem_limit\": str(int(to_rational(self.memory))) if self.memory else None,\n            \"nano_cpus\": int(to_rational(self.cpu) * 10**9) if self.cpu else None,\n            \"device_requests\": (\n                [\n                    DeviceRequest(\n                        capabilities=[[\"gpu\"]],\n                        count=self.gpu,\n                    )\n                ]\n                if self.gpu\n                else None\n            ),\n        }\n        return remove_none_values(options)\n\n    def to_kubernetes(\n        self, kind: K8sResourceKind = K8sResourceKind.REQUESTS\n    ) -&gt; K8sResourceOptions:\n        # TODO: Currently kind is not accessed and the logic for \"request\" and \"limit\" is the same.\n        # Down the road we have to decide if we want to keep it that way (and get rid of the distinction and arguments),\n        # or if it makes sense for us to distinguish both cases.\n        options: K8sResourceOptions = {\n            \"cpu\": self.cpu or None,\n            \"memory\": self.memory or None,\n            \"nvidia.com/gpu\": self.gpu or None,\n        }\n        return remove_none_values(options)\n\n    def to_ray(self) -&gt; RayResourceOptions:\n        options: RayResourceOptions = {\n            \"entrypoint_memory\": int(to_rational(self.memory)) if self.memory else None,\n            \"entrypoint_num_cpus\": int(to_rational(self.cpu)) if self.cpu else None,\n            \"entrypoint_num_gpus\": self.gpu or None,\n        }\n        return remove_none_values(options)\n</code></pre>"},{"location":"reference/jobq/job/#jobq.job.ResourceOptions.memory","title":"memory  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>memory: StrictStr | None = None\n</code></pre> <p>Memory required for pods hosting the job.</p>"},{"location":"reference/jobq/job/#jobq.job.ResourceOptions.cpu","title":"cpu  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cpu: StrictStr | None = None\n</code></pre> <p>CPUs to request for pods hosting the job.</p>"},{"location":"reference/jobq/job/#jobq.job.ResourceOptions.gpu","title":"gpu  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gpu: StrictInt | None = None\n</code></pre> <p>GPUs to request for pods hosting the job.</p>"},{"location":"reference/jobq/job/#jobq.job.ResourceOptions.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>client/src/jobq/job.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/jobq/job/#jobq.job.SchedulingOptions","title":"SchedulingOptions","text":"<p>               Bases: <code>BaseModel</code></p> <p>Options configuring a <code>jobq.Job</code>'s priority in the cluster, and the Kueue cluster queue name the job should be submitted to.</p> Source code in <code>client/src/jobq/job.py</code> <pre><code>class SchedulingOptions(BaseModel):\n    \"\"\"\n    Options configuring a ``jobq.Job``'s priority in the cluster, and\n    the Kueue cluster queue name the job should be submitted to.\n    \"\"\"\n\n    priority_class: StrictStr | None = None\n    \"\"\"Name of a Kueue priority class to use for the job. Must exist in the target cluster.\"\"\"\n    queue_name: StrictStr\n    \"\"\"The Kueue cluster queue name to submit the job to. Must refer to an existing queue\n     in the cluster, otherwise the resulting workload will be marked inadmissible.\"\"\"\n    __properties: ClassVar[list[str]] = [\"priority_class\", \"queue_name\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of SchedulingOptions from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: AbstractSet[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        # set to None if priority_class (nullable) is None\n        # and model_fields_set contains the field\n        if self.priority_class is None and \"priority_class\" in self.model_fields_set:\n            _dict[\"priority_class\"] = None\n\n        # set to None if queue_name (nullable) is None\n        # and model_fields_set contains the field\n        if self.queue_name is None and \"queue_name\" in self.model_fields_set:\n            _dict[\"queue_name\"] = None\n\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of SchedulingOptions from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"priority_class\": obj.get(\"priority_class\"),\n            \"queue_name\": obj.get(\"queue_name\"),\n        })\n        return _obj\n</code></pre>"},{"location":"reference/jobq/job/#jobq.job.SchedulingOptions.priority_class","title":"priority_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority_class: StrictStr | None = None\n</code></pre> <p>Name of a Kueue priority class to use for the job. Must exist in the target cluster.</p>"},{"location":"reference/jobq/job/#jobq.job.SchedulingOptions.queue_name","title":"queue_name  <code>instance-attribute</code>","text":"<pre><code>queue_name: StrictStr\n</code></pre> <p>The Kueue cluster queue name to submit the job to. Must refer to an existing queue in the cluster, otherwise the resulting workload will be marked inadmissible.</p>"},{"location":"reference/jobq/job/#jobq.job.SchedulingOptions.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>client/src/jobq/job.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/jobq/job/#jobq.job.SchedulingOptions.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>client/src/jobq/job.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/jobq/job/#jobq.job.SchedulingOptions.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of SchedulingOptions from a JSON string</p> Source code in <code>client/src/jobq/job.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of SchedulingOptions from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/jobq/job/#jobq.job.SchedulingOptions.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>client/src/jobq/job.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: AbstractSet[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    # set to None if priority_class (nullable) is None\n    # and model_fields_set contains the field\n    if self.priority_class is None and \"priority_class\" in self.model_fields_set:\n        _dict[\"priority_class\"] = None\n\n    # set to None if queue_name (nullable) is None\n    # and model_fields_set contains the field\n    if self.queue_name is None and \"queue_name\" in self.model_fields_set:\n        _dict[\"queue_name\"] = None\n\n    return _dict\n</code></pre>"},{"location":"reference/jobq/job/#jobq.job.SchedulingOptions.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of SchedulingOptions from a dict</p> Source code in <code>client/src/jobq/job.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of SchedulingOptions from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"priority_class\": obj.get(\"priority_class\"),\n        \"queue_name\": obj.get(\"queue_name\"),\n    })\n    return _obj\n</code></pre>"},{"location":"reference/jobq/job/#jobq.job.JobOptions","title":"JobOptions","text":"<p>               Bases: <code>JsonSerializable</code>, <code>DictSerializable</code>, <code>BaseModel</code></p> <p>Options for customizing a Kubernetes job definition from a Python function.</p> Source code in <code>client/src/jobq/job.py</code> <pre><code>class JobOptions(JsonSerializable, DictSerializable, BaseModel):\n    \"\"\"\n    Options for customizing a Kubernetes job definition from a Python function.\n    \"\"\"\n\n    resources: ResourceOptions | None = None\n    \"\"\"Compute resources to request for the job.\"\"\"\n    scheduling: SchedulingOptions\n    \"\"\"Information about the Kueue cluster queue, and job priority.\"\"\"\n    labels: dict[str, StrictStr] = Field(default_factory=dict)\n    \"\"\"Kubernetes labels to attach to the resulting Kueue workload.\"\"\"\n    __properties: ClassVar[list[str]] = [\"resources\", \"scheduling\", \"labels\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/jobq/job/#jobq.job.JobOptions.resources","title":"resources  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resources: ResourceOptions | None = None\n</code></pre> <p>Compute resources to request for the job.</p>"},{"location":"reference/jobq/job/#jobq.job.JobOptions.scheduling","title":"scheduling  <code>instance-attribute</code>","text":"<pre><code>scheduling: SchedulingOptions\n</code></pre> <p>Information about the Kueue cluster queue, and job priority.</p>"},{"location":"reference/jobq/job/#jobq.job.JobOptions.labels","title":"labels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>labels: dict[str, StrictStr] = Field(default_factory=dict)\n</code></pre> <p>Kubernetes labels to attach to the resulting Kueue workload.</p>"},{"location":"reference/jobq/job/#jobq.job.JobOptions.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>client/src/jobq/job.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/jobq/job/#jobq.job.Job","title":"Job","text":"<p>               Bases: <code>Generic[P, T]</code></p> Source code in <code>client/src/jobq/job.py</code> <pre><code>class Job(Generic[P, T]):\n    def __init__(\n        self,\n        func: Callable[P, T],\n        *,\n        options: JobOptions | None = None,\n        image: ImageOptions | None = None,\n        build_context: Path | None = None,\n    ) -&gt; None:\n        functools.update_wrapper(self, func)\n        self._func = func\n        self.options = options\n        self.image = image\n\n        if (module := inspect.getmodule(self._func)) is None:\n            raise ValueError(\"Cannot derive module for Job function.\")\n\n        job_file = Path(str(module.__file__))\n        self._name = self._func.__name__\n        self.build_context = (\n            build_context\n            if build_context is not None\n            else self._resolve_build_context(job_file)\n        )\n        self._file = job_file.relative_to(self.build_context)\n        self.validate()\n\n    def _resolve_build_context(self, job_file: Path) -&gt; Path:\n        max_depth = 15\n        build_context = job_file.resolve()\n        for _ in range(max_depth):\n            if self._is_project_root(build_context):\n                break\n            build_context = build_context.parent\n        else:\n            raise ValueError(\n                f\"Could not resolve build context from job file {self._file}, traversed {max_depth} up.\"\n            )\n        return build_context\n\n    @classmethod\n    def _is_project_root(cls, path: Path) -&gt; bool:\n        indicators = [\n            \".git\",\n            \"pyproject.toml\",\n            \"setup.py\",\n        ]\n        return any((path / indicator).exists() for indicator in indicators)\n\n    @property\n    def name(self) -&gt; str:\n        return self._name\n\n    @property\n    def file(self) -&gt; str:\n        return str(self._file)\n\n    def __call__(self, *args: P.args, **kwargs: P.kwargs) -&gt; T:\n        return self._func(*args, **kwargs)\n\n    def _resolve_path_in_build_context(self, path: Path) -&gt; Path:\n        if self.build_context is None:\n            raise ValueError(\"Build context not resolved\")\n\n        resolved_path = self.build_context / path\n\n        if not resolved_path.is_file():\n            raise FileNotFoundError(\n                f\"Could not resolve path {path!r}. Path must be relative to resolved build context, {self.build_context!r}\",\n                resolved_path,\n            )\n\n        return resolved_path\n\n    def _render_dockerfile(self) -&gt; str:\n        \"\"\"Render the job's Dockerfile from a YAML spec.\"\"\"\n\n        if not (self.image):\n            raise ValueError(\"Container image options must be specified\")\n\n        if not self.image.spec:\n            raise ValueError(\"Container image spec must be specified\")\n\n        image_spec = self._resolve_path_in_build_context(self.image.spec)\n\n        image_cfg = config.load_config(image_spec)\n\n        renderers = [cls(image_cfg) for cls in RENDERERS if cls.accepts(image_cfg)]\n        dockerfile_content = \"\"\n        for r in renderers:\n            dockerfile_content += r.render() + \"\\n\"\n        return dockerfile_content\n\n    def validate(self) -&gt; None:\n        if self.options:\n            validate_labels(self.options.labels)\n\n    def build_image(\n        self,\n        push: bool = False,\n    ) -&gt; Image | None:\n        if not self.image:\n            raise ValueError(\"Need image options to build image\")\n        opts = self.image\n\n        tag = f\"{opts.name or self.name}:{opts.tag}\"\n\n        logging.info(f\"Building container image: {tag!r}\")\n\n        build_cmd = [\"docker\", \"build\", \"-t\", tag]\n        labels = self.options.labels if self.options else {}\n        build_cmd.extend([f\"--label={k}={v}\" for k, v in labels.items()])\n\n        exit_code: int = -1\n        if opts.build_mode == BuildMode.YAML:\n            yaml = self._render_dockerfile()\n            with io.StringIO(yaml) as dockerfile:\n                build_cmd.extend([\"-f-\", f\"{self.build_context.absolute()}\"])\n                exit_code, _, _, _ = run_command(\n                    shlex.join(build_cmd),\n                    stdin=dockerfile,\n                    verbose=True,\n                )\n        elif opts.build_mode == BuildMode.DOCKERFILE:\n            if not opts.dockerfile:\n                raise ValueError(\"Dockerfile path must be specified\")\n            build_cmd.extend([\n                \"-f\",\n                f\"{self._resolve_path_in_build_context(opts.dockerfile)}\",\n                f\"{self.build_context.absolute()}\",\n            ])\n            exit_code, _, _, _ = run_command(\n                shlex.join(build_cmd),\n                verbose=True,\n            )\n\n        if exit_code == 0:\n            if push:\n                logging.info(\"Pushing container image to remote registry\")\n                exit_code, _, _, _ = run_command(\n                    f\"docker push {tag}\",\n                    verbose=True,\n                )\n                if exit_code != 0:\n                    return None\n\n            return Image(tag)\n        else:\n            return None\n</code></pre>"},{"location":"reference/jobq/job/#jobq.job.job","title":"job","text":"<pre><code>job(\n    *, options: JobOptions | None = None, image: ImageOptions | None = None\n) -&gt; Callable[[Callable[P, T]], Job[P, T]]\n</code></pre> <p>A decorator to declare a Python function as a Kubernetes job, to be packaged and sent to a Kueue cluster queue for execution.</p> PARAMETER DESCRIPTION <code>options</code> <p>Additional options to customize the job with. The given options influence scheduling, resource allocation for the job in the cluster, and labels to identify the job with.</p> <p> TYPE: <code>JobOptions | None</code> DEFAULT: <code>None</code> </p> <code>image</code> <p>Options for customizing the Docker image build. Includes the image name, tag, and either a YAML spec file to build a Dockerfile from, or alternatively, a path to a pre-existing Dockerfile.</p> <p> TYPE: <code>ImageOptions | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Job</code> <p>The actual Job instance wrapping the decorated function.</p> Source code in <code>client/src/jobq/job.py</code> <pre><code>def job(\n    *,\n    options: JobOptions | None = None,\n    image: ImageOptions | None = None,\n) -&gt; Callable[[Callable[P, T]], Job[P, T]]:\n    \"\"\"\n    A decorator to declare a Python function as a Kubernetes job,\n    to be packaged and sent to a Kueue cluster queue for execution.\n\n    Parameters\n    ----------\n    options: JobOptions | None\n        Additional options to customize the job with. The given options\n        influence scheduling, resource allocation for the job in the cluster,\n        and labels to identify the job with.\n    image: ImageOptions | None\n        Options for customizing the Docker image build. Includes the image name,\n        tag, and either a YAML spec file to build a Dockerfile from, or\n        alternatively, a path to a pre-existing Dockerfile.\n\n    Returns\n    -------\n    Job\n        The actual Job instance wrapping the decorated function.\n\n    \"\"\"\n\n    def _wrapper(fn: Callable[P, T]) -&gt; Job[P, T]:\n        return Job(\n            fn,\n            options=options,\n            image=image,\n        )\n\n    return _wrapper\n</code></pre>"},{"location":"reference/jobq/job/#jobq.job.validate_labels","title":"validate_labels","text":"<pre><code>validate_labels(labels: dict[str, str]) -&gt; None\n</code></pre> <p>Validate the syntactic correctness of user-specified job labels.</p> <p>Note that the rules for labels are the intersection (i.e., the strictest subset) of syntax restrictions on Docker labels and Kubernetes annotations, so that the labels can be applied in either context.</p> <p>See the following documents for further reference: - Docker: https://docs.docker.com/config/labels-custom-metadata/#value-guidelines - Kubernetes: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set</p> RAISES DESCRIPTION <code>ValueError</code> <p>if the labels are not well-formed</p> Source code in <code>client/src/jobq/job.py</code> <pre><code>def validate_labels(labels: dict[str, str]) -&gt; None:\n    \"\"\"Validate the syntactic correctness of user-specified job labels.\n\n    Note that the rules for labels are the intersection (i.e., the strictest subset)\n    of syntax restrictions on Docker labels and Kubernetes annotations, so that the\n    labels can be applied in either context.\n\n    See the following documents for further reference:\n    - Docker: &lt;https://docs.docker.com/config/labels-custom-metadata/#value-guidelines&gt;\n    - Kubernetes: &lt;https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set&gt;\n\n    Raises\n    ------\n    ValueError\n        if the labels are not well-formed\n    \"\"\"\n    for k, v in labels.items():\n        # Label keys:\n        # - Must start and end with a letter\n        # - Can contain dashes (-), underscores (_), dots (.), slashes (/), and alphanumerics between.\n        # - May not contain prefixes (as used in Kubernetes), since they are not compatible with Docker\n        if not re.match(r\"^[a-z]+(?:[/._-][a-z0-9]+)*[a-z]?$\", k):\n            raise ValueError(f\"Label key is not well-formed: {k}\")\n\n        # Label values:\n        # - Maximum length of 127 characters\n        if len(v) &gt; 127:\n            raise ValueError(f\"Label value is not well-formed: {v}\")\n</code></pre>"},{"location":"reference/jobq/submission_context/","title":"submission_context","text":""},{"location":"reference/jobq/types/","title":"types","text":""},{"location":"reference/jobq/types/#jobq.types.JsonSerializable","title":"JsonSerializable","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin to mark a Pydantic model that can be (de-)serialized to JSON</p> Source code in <code>client/src/jobq/types.py</code> <pre><code>class JsonSerializable(BaseModel):\n    \"\"\"Mixin to mark a Pydantic model that can be (de-)serialized to JSON\"\"\"\n\n    def to_json(self) -&gt; str:\n        return self.model_dump_json(by_alias=True, exclude_unset=True)\n\n    @classmethod\n    def from_json(cls, json_data: str) -&gt; Self:\n        return cls.model_validate_json(json_data)\n</code></pre>"},{"location":"reference/jobq/types/#jobq.types.DictSerializable","title":"DictSerializable","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin to mark a Pydantic model that can be (de-)serialized to a Python dict</p> Source code in <code>client/src/jobq/types.py</code> <pre><code>class DictSerializable(BaseModel):\n    \"\"\"Mixin to mark a Pydantic model that can be (de-)serialized to a Python dict\"\"\"\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        return self.model_dump(by_alias=True, exclude_none=True)\n\n    @classmethod\n    def from_dict(cls, obj: Any) -&gt; Self:\n        return cls.model_validate(obj)\n</code></pre>"},{"location":"reference/jobq/assembler/","title":"assembler","text":""},{"location":"reference/jobq/assembler/config/","title":"config","text":""},{"location":"reference/jobq/assembler/config/#jobq.assembler.config.Identifier","title":"Identifier  <code>module-attribute</code>","text":"<pre><code>Identifier = TypeAliasType('Identifier', Annotated[int, Interval(ge=0, le=65535)])\n</code></pre> <p>UID/GID identifier type</p>"},{"location":"reference/jobq/assembler/renderers/","title":"renderers","text":""},{"location":"reference/jobq/utils/","title":"utils","text":""},{"location":"reference/jobq/utils/helpers/","title":"helpers","text":""},{"location":"reference/jobq/utils/helpers/#jobq.utils.helpers.remove_none_values","title":"remove_none_values","text":"<pre><code>remove_none_values(d: T) -&gt; T\n</code></pre> <p>Remove all keys with a <code>None</code> value from a dict.</p> Source code in <code>client/src/jobq/utils/helpers.py</code> <pre><code>def remove_none_values(d: T) -&gt; T:\n    \"\"\"Remove all keys with a ``None`` value from a dict.\"\"\"\n    filtered_dict = {k: v for k, v in d.items() if v is not None}\n    return cast(T, filtered_dict)\n</code></pre>"},{"location":"reference/jobq/utils/helpers/#jobq.utils.helpers.snake_to_human","title":"snake_to_human","text":"<pre><code>snake_to_human(s: str) -&gt; str\n</code></pre> <p>Convert a snake_case string to a human-readable string.</p> Source code in <code>client/src/jobq/utils/helpers.py</code> <pre><code>def snake_to_human(s: str) -&gt; str:\n    \"\"\"Convert a snake_case string to a human-readable string.\"\"\"\n    return s.replace(\"_\", \" \")\n</code></pre>"},{"location":"reference/jobq/utils/helpers/#jobq.utils.helpers.camel_to_human","title":"camel_to_human","text":"<pre><code>camel_to_human(s: str) -&gt; str\n</code></pre> <p>Convert a camelCase string to a human-readable string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; camel_to_human(\"camelCase\")\n'Camel Case'\n&gt;&gt;&gt; camel_to_human(\"camelCaseString\")\n'Camel Case String'\n&gt;&gt;&gt; camel_to_human(\"randomID\")\n'Random ID'\n</code></pre> Source code in <code>client/src/jobq/utils/helpers.py</code> <pre><code>def camel_to_human(s: str) -&gt; str:\n    \"\"\"Convert a camelCase string to a human-readable string.\n\n    Examples\n    --------\n    &gt;&gt;&gt; camel_to_human(\"camelCase\")\n    'Camel Case'\n    &gt;&gt;&gt; camel_to_human(\"camelCaseString\")\n    'Camel Case String'\n    &gt;&gt;&gt; camel_to_human(\"randomID\")\n    'Random ID'\n    \"\"\"\n    # Use regex to find positions where a lowercase letter is followed by an uppercase letter\n    s = re.sub(\"([a-z])([A-Z])\", r\"\\1 \\2\", s)\n\n    # Capitalize the first letter of each word\n    return s\n</code></pre>"},{"location":"reference/jobq/utils/helpers/#jobq.utils.helpers.to_human","title":"to_human","text":"<pre><code>to_human(s: str) -&gt; str\n</code></pre> <p>Convert a string to a human-readable string.</p> Source code in <code>client/src/jobq/utils/helpers.py</code> <pre><code>def to_human(s: str) -&gt; str:\n    \"\"\"Convert a string to a human-readable string.\"\"\"\n    result = s\n    if s.islower():\n        result = snake_to_human(s)\n    else:\n        result = camel_to_human(s)\n    return result.title()\n</code></pre>"},{"location":"reference/jobq/utils/helpers/#jobq.utils.helpers.format_dict","title":"format_dict","text":"<pre><code>format_dict(d: Mapping[str, Any], level: int = 0, indent_width: int = 2) -&gt; str\n</code></pre> <p>Format a dict in a human-readable format.</p> <p>Simple values are printed as-is, lists are printed as comma-separated values, and dicts are recursively formatted with keys as section headers.</p> Source code in <code>client/src/jobq/utils/helpers.py</code> <pre><code>def format_dict(d: Mapping[str, Any], level: int = 0, indent_width: int = 2) -&gt; str:\n    \"\"\"Format a dict in a human-readable format.\n\n    Simple values are printed as-is, lists are printed as comma-separated values,\n    and dicts are recursively formatted with keys as section headers.\n    \"\"\"\n\n    def format_value(value: Any, level: int) -&gt; str:\n        if isinstance(value, Mapping):\n            return format_dict(value, level + 1)\n        elif isinstance(value, list):\n            return \"\\n\".join(\n                \" \" * ((level + 1) * indent_width)\n                + \"- \"\n                + format_value(item, level + 1).strip()\n                for item in value\n            )\n        else:\n            strval = str(value).strip()\n            if \"\\n\" in strval:\n                return \"\\n\" + textwrap.indent(\n                    strval, prefix=\" \" * (level * indent_width)\n                )\n            else:\n                return strval\n\n    indent = \" \" * (level * indent_width)\n    formatted_items = []\n\n    for key, value in d.items():\n        formatted_value = format_value(value, level) or f\"{indent}    &lt;empty&gt;\"\n        header = f\"{indent}{to_human(key)}\"\n\n        if isinstance(value, list | Mapping):\n            formatted_items.append(f\"{header}:\\n{formatted_value}\\n\")\n        else:\n            formatted_items.append(f\"{header}: {formatted_value}\")\n\n    return \"\\n\".join(formatted_items)\n</code></pre>"},{"location":"reference/jobq/utils/math/","title":"math","text":""},{"location":"reference/jobq/utils/math/#jobq.utils.math.to_rational","title":"to_rational","text":"<pre><code>to_rational(s: str) -&gt; float\n</code></pre> <p>Convert a number with optional SI/binary unit to floating-point</p> Source code in <code>client/src/jobq/utils/math.py</code> <pre><code>def to_rational(s: str) -&gt; float:\n    \"\"\"Convert a number with optional SI/binary unit to floating-point\"\"\"\n\n    matches = re.match(r\"(?P&lt;magnitude&gt;[+\\-]?\\d*[.,]?\\d+)(?P&lt;suffix&gt;[a-zA-Z]*)\", s)\n    if not matches:\n        raise ValueError(f\"Could not parse {s}\")\n    magnitude = float(matches.group(\"magnitude\"))\n    suffix = matches.group(\"suffix\")\n\n    factor = {\n        # SI / Metric\n        \"m\": 1e-3,\n        \"k\": 1e3,\n        \"M\": 1e6,\n        \"G\": 1e9,\n        \"T\": 1e12,\n        # Binary\n        \"Ki\": 2**10,\n        \"Mi\": 2**20,\n        \"Gi\": 2**30,\n        \"Ti\": 2**40,\n        # default\n        \"\": 1.0,\n    }.get(suffix)\n    if factor is None:\n        raise ValueError(f\"unknown unit suffix: {suffix}\")\n\n    return factor * magnitude\n</code></pre>"},{"location":"reference/jobq/utils/processes/","title":"processes","text":""},{"location":"reference/jobq/utils/processes/#jobq.utils.processes.run_command","title":"run_command","text":"<pre><code>run_command(\n    command: str,\n    cwd: AnyPath | None = None,\n    verbose: bool = False,\n    env: Mapping[str, str] | None = None,\n    stdin: TextIO | None = None,\n) -&gt; tuple[int, list[str], list[str], list[str]]\n</code></pre> <p>Run a command in a subprocess.</p> PARAMETER DESCRIPTION <code>command</code> <p>Command to run</p> <p> TYPE: <code>str</code> </p> <code>cwd</code> <p>Working directory</p> <p> TYPE: <code>PathLike[str] | Path | None</code> DEFAULT: <code>None</code> </p> <code>verbose</code> <p>Forward command output to stdout/stderr</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>env</code> <p>Environment for the new process, by default the current environment</p> <p> TYPE: <code>dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>stdin</code> <p>Standard input for the new process, by default <code>None</code></p> <p> TYPE: <code>BinaryIO | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>tuple[int, list[str], list[str], list[str]]</code> <p>a tuple containing the return code and the output of the command (stdout, stderr, and combined)</p> Source code in <code>client/src/jobq/utils/processes.py</code> <pre><code>def run_command(\n    command: str,\n    cwd: AnyPath | None = None,\n    verbose: bool = False,\n    env: Mapping[str, str] | None = None,\n    stdin: TextIO | None = None,\n) -&gt; tuple[int, list[str], list[str], list[str]]:\n    \"\"\"Run a command in a subprocess.\n\n    Parameters\n    ----------\n    command : str\n        Command to run\n    cwd : os.PathLike[str] | Path | None, optional\n        Working directory\n    verbose : bool, optional\n        Forward command output to stdout/stderr\n    env : dict[str, str], optional\n        Environment for the new process, by default the current environment\n    stdin : BinaryIO | None, optional\n        Standard input for the new process, by default `None`\n\n    Returns\n    -------\n    tuple[int, list[str], list[str], list[str]]\n        a tuple containing the return code and the output of the command (stdout, stderr, and combined)\n    \"\"\"\n\n    logging.debug(\"Running command: %s\", command)\n    # No need to split the command string on Windows\n    if sys.platform == \"win32\":\n        args = command\n    else:\n        args = shlex.split(command)\n\n    process = subprocess.Popen(\n        args=args,\n        stdin=subprocess.PIPE if stdin else None,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        cwd=cwd,\n        env=env,\n        encoding=\"utf-8\",\n    )\n\n    if stdin is not None and process.stdin:\n        process.stdin.write(stdin.read())\n        process.stdin.close()\n\n    # Capture stdout and stderr\n    stdout: list[str] = []\n    stderr: list[str] = []\n    output: list[str] = []\n\n    def _reader(\n        in_stream: TextIO | None,\n        out_stream: TextIOBase,\n        out_lists: Iterable[list[str]],\n    ) -&gt; None:\n        if in_stream is None:\n            return\n        for line in in_stream:\n            for out in out_lists:\n                out.append(line)\n\n            if verbose:\n                out_stream.write(line)\n                out_stream.flush()\n\n    read_stdout = threading.Thread(\n        target=_reader,\n        kwargs={\n            \"in_stream\": process.stdout,\n            \"out_stream\": sys.stdout,\n            \"out_lists\": [stdout, output],\n        },\n    )\n    read_stderr = threading.Thread(\n        target=_reader,\n        kwargs={\n            \"in_stream\": process.stderr,\n            \"out_stream\": sys.stderr,\n            \"out_lists\": [stderr, output],\n        },\n    )\n\n    read_stdout.start()\n    read_stderr.start()\n\n    # Wait for process to finish\n    while process.poll() is None:\n        time.sleep(0.1)\n\n    read_stdout.join()\n    read_stderr.join()\n\n    return process.returncode, stdout, stderr, output\n</code></pre>"},{"location":"reference/openapi_client/","title":"openapi_client","text":"<p>the jobq cluster workflow management tool backend</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/api_client/","title":"api_client","text":"<p>the jobq cluster workflow management tool backend</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient","title":"ApiClient","text":"<p>Generic API client for OpenAPI client library builds.</p> <p>OpenAPI generic API client. This client handles the client- server communication, and is invariant across implementations. Specifics of the methods and models for each application are generated from the OpenAPI templates.</p> <p>:param configuration: .Configuration object for this client :param header_name: a header to pass when making calls to the API. :param header_value: a header value to pass when making calls to     the API. :param cookie: a cookie to include in the header when making calls     to the API</p> Source code in <code>client/src/openapi_client/api_client.py</code> <pre><code>class ApiClient:\n    \"\"\"Generic API client for OpenAPI client library builds.\n\n    OpenAPI generic API client. This client handles the client-\n    server communication, and is invariant across implementations. Specifics of\n    the methods and models for each application are generated from the OpenAPI\n    templates.\n\n    :param configuration: .Configuration object for this client\n    :param header_name: a header to pass when making calls to the API.\n    :param header_value: a header value to pass when making calls to\n        the API.\n    :param cookie: a cookie to include in the header when making calls\n        to the API\n    \"\"\"\n\n    PRIMITIVE_TYPES = (float, bool, bytes, str, int)\n    NATIVE_TYPES_MAPPING = {\n        \"int\": int,\n        \"long\": int,  # TODO remove as only py3 is supported?\n        \"float\": float,\n        \"str\": str,\n        \"bool\": bool,\n        \"date\": datetime.date,\n        \"datetime\": datetime.datetime,\n        \"decimal\": decimal.Decimal,\n        \"object\": object,\n    }\n    _pool = None\n\n    def __init__(\n        self, configuration=None, header_name=None, header_value=None, cookie=None\n    ) -&gt; None:\n        # use default configuration if none is provided\n        if configuration is None:\n            configuration = Configuration.get_default()\n        self.configuration = configuration\n\n        self.rest_client = rest.RESTClientObject(configuration)\n        self.default_headers = {}\n        if header_name is not None:\n            self.default_headers[header_name] = header_value\n        self.cookie = cookie\n        # Set default User-Agent.\n        self.user_agent = \"OpenAPI-Generator/1.0.0/python\"\n        self.client_side_validation = configuration.client_side_validation\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        pass\n\n    @property\n    def user_agent(self):\n        \"\"\"User agent for this API client\"\"\"\n        return self.default_headers[\"User-Agent\"]\n\n    @user_agent.setter\n    def user_agent(self, value):\n        self.default_headers[\"User-Agent\"] = value\n\n    def set_default_header(self, header_name, header_value):\n        self.default_headers[header_name] = header_value\n\n    _default = None\n\n    @classmethod\n    def get_default(cls):\n        \"\"\"Return new instance of ApiClient.\n\n        This method returns newly created, based on default constructor,\n        object of ApiClient class or returns a copy of default\n        ApiClient.\n\n        :return: The ApiClient object.\n        \"\"\"\n        if cls._default is None:\n            cls._default = ApiClient()\n        return cls._default\n\n    @classmethod\n    def set_default(cls, default):\n        \"\"\"Set default instance of ApiClient.\n\n        It stores default ApiClient.\n\n        :param default: object of ApiClient.\n        \"\"\"\n        cls._default = default\n\n    def param_serialize(\n        self,\n        method,\n        resource_path,\n        path_params=None,\n        query_params=None,\n        header_params=None,\n        body=None,\n        post_params=None,\n        files=None,\n        auth_settings=None,\n        collection_formats=None,\n        _host=None,\n        _request_auth=None,\n    ) -&gt; RequestSerialized:\n        \"\"\"Builds the HTTP request params needed by the request.\n        :param method: Method to call.\n        :param resource_path: Path to method endpoint.\n        :param path_params: Path parameters in the url.\n        :param query_params: Query parameters in the url.\n        :param header_params: Header parameters to be\n            placed in the request header.\n        :param body: Request body.\n        :param post_params dict: Request post form parameters,\n            for `application/x-www-form-urlencoded`, `multipart/form-data`.\n        :param auth_settings list: Auth Settings names for the request.\n        :param files dict: key -&gt; filename, value -&gt; filepath,\n            for `multipart/form-data`.\n        :param collection_formats: dict of collection formats for path, query,\n            header, and post parameters.\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the authentication\n                              in the spec for a single request.\n        :return: tuple of form (path, http_method, query_params, header_params,\n            body, post_params, files)\n        \"\"\"\n\n        config = self.configuration\n\n        # header parameters\n        header_params = header_params or {}\n        header_params.update(self.default_headers)\n        if self.cookie:\n            header_params[\"Cookie\"] = self.cookie\n        if header_params:\n            header_params = self.sanitize_for_serialization(header_params)\n            header_params = dict(\n                self.parameters_to_tuples(header_params, collection_formats)\n            )\n\n        # path parameters\n        if path_params:\n            path_params = self.sanitize_for_serialization(path_params)\n            path_params = self.parameters_to_tuples(path_params, collection_formats)\n            for k, v in path_params:\n                # specified safe chars, encode everything\n                resource_path = resource_path.replace(\n                    f\"{{{k}}}\", quote(str(v), safe=config.safe_chars_for_path_param)\n                )\n\n        # post parameters\n        if post_params or files:\n            post_params = post_params if post_params else []\n            post_params = self.sanitize_for_serialization(post_params)\n            post_params = self.parameters_to_tuples(post_params, collection_formats)\n            if files:\n                post_params.extend(self.files_parameters(files))\n\n        # auth setting\n        self.update_params_for_auth(\n            header_params,\n            query_params,\n            auth_settings,\n            resource_path,\n            method,\n            body,\n            request_auth=_request_auth,\n        )\n\n        # body\n        if body:\n            body = self.sanitize_for_serialization(body)\n\n        # request url\n        if _host is None or self.configuration.ignore_operation_servers:\n            url = self.configuration.host + resource_path\n        else:\n            # use server/host defined in path or operation instead\n            url = _host + resource_path\n\n        # query parameters\n        if query_params:\n            query_params = self.sanitize_for_serialization(query_params)\n            url_query = self.parameters_to_url_query(query_params, collection_formats)\n            url += \"?\" + url_query\n\n        return method, url, header_params, body, post_params\n\n    def call_api(\n        self,\n        method,\n        url,\n        header_params=None,\n        body=None,\n        post_params=None,\n        _request_timeout=None,\n    ) -&gt; rest.RESTResponse:\n        \"\"\"Makes the HTTP request (synchronous)\n        :param method: Method to call.\n        :param url: Path to method endpoint.\n        :param header_params: Header parameters to be\n            placed in the request header.\n        :param body: Request body.\n        :param post_params dict: Request post form parameters,\n            for `application/x-www-form-urlencoded`, `multipart/form-data`.\n        :param _request_timeout: timeout setting for this request.\n        :return: RESTResponse\n        \"\"\"\n\n        try:\n            # perform request and return response\n            response_data = self.rest_client.request(\n                method,\n                url,\n                headers=header_params,\n                body=body,\n                post_params=post_params,\n                _request_timeout=_request_timeout,\n            )\n\n        except ApiException as e:\n            raise e\n\n        return response_data\n\n    def response_deserialize(\n        self,\n        response_data: rest.RESTResponse,\n        response_types_map: dict[str, ApiResponseT] | None = None,\n    ) -&gt; ApiResponse[ApiResponseT]:\n        \"\"\"Deserializes response into an object.\n        :param response_data: RESTResponse object to be deserialized.\n        :param response_types_map: dict of response types.\n        :return: ApiResponse\n        \"\"\"\n\n        msg = \"RESTResponse.read() must be called before passing it to response_deserialize()\"\n        assert response_data.data is not None, msg\n\n        response_type = response_types_map.get(str(response_data.status), None)\n        if (\n            not response_type\n            and isinstance(response_data.status, int)\n            and 100 &lt;= response_data.status &lt;= 599\n        ):\n            # if not found, look for '1XX', '2XX', etc.\n            response_type = response_types_map.get(\n                str(response_data.status)[0] + \"XX\", None\n            )\n\n        # deserialize response data\n        response_text = None\n        return_data = None\n        try:\n            if response_type == \"bytearray\":\n                return_data = response_data.data\n            elif response_type == \"file\":\n                return_data = self.__deserialize_file(response_data)\n            elif response_type is not None:\n                match = None\n                content_type = response_data.getheader(\"content-type\")\n                if content_type is not None:\n                    match = re.search(r\"charset=([a-zA-Z\\-\\d]+)[\\s;]?\", content_type)\n                encoding = match.group(1) if match else \"utf-8\"\n                response_text = response_data.data.decode(encoding)\n                return_data = self.deserialize(\n                    response_text, response_type, content_type\n                )\n        finally:\n            if not 200 &lt;= response_data.status &lt;= 299:\n                raise ApiException.from_response(\n                    http_resp=response_data,\n                    body=response_text,\n                    data=return_data,\n                )\n\n        return ApiResponse(\n            status_code=response_data.status,\n            data=return_data,\n            headers=response_data.getheaders(),\n            raw_data=response_data.data,\n        )\n\n    def sanitize_for_serialization(self, obj):\n        \"\"\"Builds a JSON POST object.\n\n        If obj is None, return None.\n        If obj is SecretStr, return obj.get_secret_value()\n        If obj is str, int, long, float, bool, return directly.\n        If obj is datetime.datetime, datetime.date\n            convert to string in iso8601 format.\n        If obj is decimal.Decimal return string representation.\n        If obj is list, sanitize each element in the list.\n        If obj is dict, return the dict.\n        If obj is OpenAPI model, return the properties dict.\n\n        :param obj: The data to serialize.\n        :return: The serialized form of data.\n        \"\"\"\n        if obj is None:\n            return None\n        elif isinstance(obj, Enum):\n            return obj.value\n        elif isinstance(obj, SecretStr):\n            return obj.get_secret_value()\n        elif isinstance(obj, self.PRIMITIVE_TYPES):\n            return obj\n        elif isinstance(obj, list):\n            return [self.sanitize_for_serialization(sub_obj) for sub_obj in obj]\n        elif isinstance(obj, tuple):\n            return tuple(self.sanitize_for_serialization(sub_obj) for sub_obj in obj)\n        elif isinstance(obj, datetime.datetime | datetime.date):\n            return obj.isoformat()\n        elif isinstance(obj, decimal.Decimal):\n            return str(obj)\n\n        elif isinstance(obj, dict):\n            obj_dict = obj\n        else:\n            # Convert model obj to dict except\n            # attributes `openapi_types`, `attribute_map`\n            # and attributes which value is not None.\n            # Convert attribute name to json key in\n            # model definition for request.\n            if hasattr(obj, \"to_dict\") and callable(obj.to_dict):\n                obj_dict = obj.to_dict()\n            else:\n                obj_dict = obj.__dict__\n\n        return {\n            key: self.sanitize_for_serialization(val) for key, val in obj_dict.items()\n        }\n\n    def deserialize(\n        self, response_text: str, response_type: str, content_type: str | None\n    ):\n        \"\"\"Deserializes response into an object.\n\n        :param response: RESTResponse object to be deserialized.\n        :param response_type: class literal for\n            deserialized object, or string of class name.\n        :param content_type: content type of response.\n\n        :return: deserialized object.\n        \"\"\"\n\n        # fetch data from response object\n        if content_type is None:\n            try:\n                data = json.loads(response_text)\n            except ValueError:\n                data = response_text\n        elif re.match(\n            r\"^application/(json|[\\w!#$&amp;.+-^_]+\\+json)\\s*(;|$)\",\n            content_type,\n            re.IGNORECASE,\n        ):\n            if response_text == \"\":\n                data = \"\"\n            else:\n                data = json.loads(response_text)\n        elif re.match(r\"^text/plain\\s*(;|$)\", content_type, re.IGNORECASE):\n            data = response_text\n        else:\n            raise ApiException(\n                status=0, reason=f\"Unsupported content type: {content_type}\"\n            )\n\n        return self.__deserialize(data, response_type)\n\n    def __deserialize(self, data, klass):\n        \"\"\"Deserializes dict, list, str into an object.\n\n        :param data: dict, list or str.\n        :param klass: class literal, or string of class name.\n\n        :return: object.\n        \"\"\"\n        if data is None:\n            return None\n\n        if isinstance(klass, str):\n            if klass.startswith(\"List[\"):\n                m = re.match(r\"List\\[(.*)]\", klass)\n                assert m is not None, \"Malformed List type definition\"\n                sub_kls = m.group(1)\n                return [self.__deserialize(sub_data, sub_kls) for sub_data in data]\n\n            if klass.startswith(\"Dict[\"):\n                m = re.match(r\"Dict\\[([^,]*), (.*)]\", klass)\n                assert m is not None, \"Malformed Dict type definition\"\n                sub_kls = m.group(2)\n                return {k: self.__deserialize(v, sub_kls) for k, v in data.items()}\n\n            # convert str to class\n            if klass in self.NATIVE_TYPES_MAPPING:\n                klass = self.NATIVE_TYPES_MAPPING[klass]\n            else:\n                klass = getattr(openapi_client.models, klass)\n\n        if klass in self.PRIMITIVE_TYPES:\n            return self.__deserialize_primitive(data, klass)\n        elif klass == object:\n            return self.__deserialize_object(data)\n        elif klass == datetime.date:\n            return self.__deserialize_date(data)\n        elif klass == datetime.datetime:\n            return self.__deserialize_datetime(data)\n        elif klass == decimal.Decimal:\n            return decimal.Decimal(data)\n        elif issubclass(klass, Enum):\n            return self.__deserialize_enum(data, klass)\n        else:\n            return self.__deserialize_model(data, klass)\n\n    def parameters_to_tuples(self, params, collection_formats):\n        \"\"\"Get parameters as list of tuples, formatting collections.\n\n        :param params: Parameters as dict or list of two-tuples\n        :param dict collection_formats: Parameter collection formats\n        :return: Parameters as list of tuples, collections formatted\n        \"\"\"\n        new_params: list[tuple[str, str]] = []\n        if collection_formats is None:\n            collection_formats = {}\n        for k, v in params.items() if isinstance(params, dict) else params:\n            if k in collection_formats:\n                collection_format = collection_formats[k]\n                if collection_format == \"multi\":\n                    new_params.extend((k, value) for value in v)\n                else:\n                    if collection_format == \"ssv\":\n                        delimiter = \" \"\n                    elif collection_format == \"tsv\":\n                        delimiter = \"\\t\"\n                    elif collection_format == \"pipes\":\n                        delimiter = \"|\"\n                    else:  # csv is the default\n                        delimiter = \",\"\n                    new_params.append((k, delimiter.join(str(value) for value in v)))\n            else:\n                new_params.append((k, v))\n        return new_params\n\n    def parameters_to_url_query(self, params, collection_formats):\n        \"\"\"Get parameters as list of tuples, formatting collections.\n\n        :param params: Parameters as dict or list of two-tuples\n        :param dict collection_formats: Parameter collection formats\n        :return: URL query string (e.g. a=Hello%20World&amp;b=123)\n        \"\"\"\n        new_params: list[tuple[str, str]] = []\n        if collection_formats is None:\n            collection_formats = {}\n        for k, v in params.items() if isinstance(params, dict) else params:\n            if isinstance(v, bool):\n                v = str(v).lower()\n            if isinstance(v, int | float):\n                v = str(v)\n            if isinstance(v, dict):\n                v = json.dumps(v)\n\n            if k in collection_formats:\n                collection_format = collection_formats[k]\n                if collection_format == \"multi\":\n                    new_params.extend((k, str(value)) for value in v)\n                else:\n                    if collection_format == \"ssv\":\n                        delimiter = \" \"\n                    elif collection_format == \"tsv\":\n                        delimiter = \"\\t\"\n                    elif collection_format == \"pipes\":\n                        delimiter = \"|\"\n                    else:  # csv is the default\n                        delimiter = \",\"\n                    new_params.append((\n                        k,\n                        delimiter.join(quote(str(value)) for value in v),\n                    ))\n            else:\n                new_params.append((k, quote(str(v))))\n\n        return \"&amp;\".join([\"=\".join(map(str, item)) for item in new_params])\n\n    def files_parameters(\n        self,\n        files: dict[str, str | bytes | list[str] | list[bytes] | tuple[str, bytes]],\n    ):\n        \"\"\"Builds form parameters.\n\n        :param files: File parameters.\n        :return: Form parameters with files.\n        \"\"\"\n        params = []\n        for k, v in files.items():\n            if isinstance(v, str):\n                with open(v, \"rb\") as f:\n                    filename = os.path.basename(f.name)\n                    filedata = f.read()\n            elif isinstance(v, bytes):\n                filename = k\n                filedata = v\n            elif isinstance(v, tuple):\n                filename, filedata = v\n            elif isinstance(v, list):\n                for file_param in v:\n                    params.extend(self.files_parameters({k: file_param}))\n                continue\n            else:\n                raise ValueError(\"Unsupported file value\")\n            mimetype = mimetypes.guess_type(filename)[0] or \"application/octet-stream\"\n            params.append((k, (filename, filedata, mimetype)))\n        return params\n\n    def select_header_accept(self, accepts: list[str]) -&gt; str | None:\n        \"\"\"Returns `Accept` based on an array of accepts provided.\n\n        :param accepts: List of headers.\n        :return: Accept (e.g. application/json).\n        \"\"\"\n        if not accepts:\n            return None\n\n        for accept in accepts:\n            if re.search(\"json\", accept, re.IGNORECASE):\n                return accept\n\n        return accepts[0]\n\n    def select_header_content_type(self, content_types):\n        \"\"\"Returns `Content-Type` based on an array of content_types provided.\n\n        :param content_types: List of content-types.\n        :return: Content-Type (e.g. application/json).\n        \"\"\"\n        if not content_types:\n            return None\n\n        for content_type in content_types:\n            if re.search(\"json\", content_type, re.IGNORECASE):\n                return content_type\n\n        return content_types[0]\n\n    def update_params_for_auth(\n        self,\n        headers,\n        queries,\n        auth_settings,\n        resource_path,\n        method,\n        body,\n        request_auth=None,\n    ) -&gt; None:\n        \"\"\"Updates header and query params based on authentication setting.\n\n        :param headers: Header parameters dict to be updated.\n        :param queries: Query parameters tuple list to be updated.\n        :param auth_settings: Authentication setting identifiers list.\n        :resource_path: A string representation of the HTTP request resource path.\n        :method: A string representation of the HTTP request method.\n        :body: A object representing the body of the HTTP request.\n        The object type is the return value of sanitize_for_serialization().\n        :param request_auth: if set, the provided settings will\n                             override the token in the configuration.\n        \"\"\"\n        if not auth_settings:\n            return\n\n        if request_auth:\n            self._apply_auth_params(\n                headers, queries, resource_path, method, body, request_auth\n            )\n        else:\n            for auth in auth_settings:\n                auth_setting = self.configuration.auth_settings().get(auth)\n                if auth_setting:\n                    self._apply_auth_params(\n                        headers, queries, resource_path, method, body, auth_setting\n                    )\n\n    def _apply_auth_params(\n        self, headers, queries, resource_path, method, body, auth_setting\n    ) -&gt; None:\n        \"\"\"Updates the request parameters based on a single auth_setting\n\n        :param headers: Header parameters dict to be updated.\n        :param queries: Query parameters tuple list to be updated.\n        :resource_path: A string representation of the HTTP request resource path.\n        :method: A string representation of the HTTP request method.\n        :body: A object representing the body of the HTTP request.\n        The object type is the return value of sanitize_for_serialization().\n        :param auth_setting: auth settings for the endpoint\n        \"\"\"\n        if auth_setting[\"in\"] == \"cookie\":\n            headers[\"Cookie\"] = auth_setting[\"value\"]\n        elif auth_setting[\"in\"] == \"header\":\n            if auth_setting[\"type\"] != \"http-signature\":\n                headers[auth_setting[\"key\"]] = auth_setting[\"value\"]\n        elif auth_setting[\"in\"] == \"query\":\n            queries.append((auth_setting[\"key\"], auth_setting[\"value\"]))\n        else:\n            raise ApiValueError(\"Authentication token must be in `query` or `header`\")\n\n    def __deserialize_file(self, response):\n        \"\"\"Deserializes body to file\n\n        Saves response body into a file in a temporary folder,\n        using the filename from the `Content-Disposition` header if provided.\n\n        handle file downloading\n        save response body into a tmp file and return the instance\n\n        :param response:  RESTResponse.\n        :return: file path.\n        \"\"\"\n        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)\n        os.close(fd)\n        os.remove(path)\n\n        content_disposition = response.getheader(\"Content-Disposition\")\n        if content_disposition:\n            m = re.search(r'filename=[\\'\"]?([^\\'\"\\s]+)[\\'\"]?', content_disposition)\n            assert m is not None, \"Unexpected 'content-disposition' header value\"\n            filename = m.group(1)\n            path = os.path.join(os.path.dirname(path), filename)\n\n        with open(path, \"wb\") as f:\n            f.write(response.data)\n\n        return path\n\n    def __deserialize_primitive(self, data, klass):\n        \"\"\"Deserializes string to primitive type.\n\n        :param data: str.\n        :param klass: class literal.\n\n        :return: int, long, float, str, bool.\n        \"\"\"\n        try:\n            return klass(data)\n        except UnicodeEncodeError:\n            return str(data)\n        except TypeError:\n            return data\n\n    def __deserialize_object(self, value):\n        \"\"\"Return an original value.\n\n        :return: object.\n        \"\"\"\n        return value\n\n    def __deserialize_date(self, string):\n        \"\"\"Deserializes string to date.\n\n        :param string: str.\n        :return: date.\n        \"\"\"\n        try:\n            return parse(string).date()\n        except ImportError:\n            return string\n        except ValueError:\n            raise rest.ApiException(\n                status=0, reason=f\"Failed to parse `{string}` as date object\"\n            )\n\n    def __deserialize_datetime(self, string):\n        \"\"\"Deserializes string to datetime.\n\n        The string should be in iso8601 datetime format.\n\n        :param string: str.\n        :return: datetime.\n        \"\"\"\n        try:\n            return parse(string)\n        except ImportError:\n            return string\n        except ValueError:\n            raise rest.ApiException(\n                status=0, reason=(f\"Failed to parse `{string}` as datetime object\")\n            )\n\n    def __deserialize_enum(self, data, klass):\n        \"\"\"Deserializes primitive type to enum.\n\n        :param data: primitive type.\n        :param klass: class literal.\n        :return: enum value.\n        \"\"\"\n        try:\n            return klass(data)\n        except ValueError:\n            raise rest.ApiException(\n                status=0, reason=(f\"Failed to parse `{data}` as `{klass}`\")\n            )\n\n    def __deserialize_model(self, data, klass):\n        \"\"\"Deserializes list or dict to model.\n\n        :param data: dict, list.\n        :param klass: class literal.\n        :return: model object.\n        \"\"\"\n\n        return klass.from_dict(data)\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.user_agent","title":"user_agent  <code>property</code> <code>writable</code>","text":"<pre><code>user_agent\n</code></pre> <p>User agent for this API client</p>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.get_default","title":"get_default  <code>classmethod</code>","text":"<pre><code>get_default()\n</code></pre> <p>Return new instance of ApiClient.</p> <p>This method returns newly created, based on default constructor, object of ApiClient class or returns a copy of default ApiClient.</p> <p>:return: The ApiClient object.</p> Source code in <code>client/src/openapi_client/api_client.py</code> <pre><code>@classmethod\ndef get_default(cls):\n    \"\"\"Return new instance of ApiClient.\n\n    This method returns newly created, based on default constructor,\n    object of ApiClient class or returns a copy of default\n    ApiClient.\n\n    :return: The ApiClient object.\n    \"\"\"\n    if cls._default is None:\n        cls._default = ApiClient()\n    return cls._default\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.set_default","title":"set_default  <code>classmethod</code>","text":"<pre><code>set_default(default)\n</code></pre> <p>Set default instance of ApiClient.</p> <p>It stores default ApiClient.</p> <p>:param default: object of ApiClient.</p> Source code in <code>client/src/openapi_client/api_client.py</code> <pre><code>@classmethod\ndef set_default(cls, default):\n    \"\"\"Set default instance of ApiClient.\n\n    It stores default ApiClient.\n\n    :param default: object of ApiClient.\n    \"\"\"\n    cls._default = default\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.param_serialize","title":"param_serialize","text":"<pre><code>param_serialize(\n    method,\n    resource_path,\n    path_params=None,\n    query_params=None,\n    header_params=None,\n    body=None,\n    post_params=None,\n    files=None,\n    auth_settings=None,\n    collection_formats=None,\n    _host=None,\n    _request_auth=None,\n) -&gt; RequestSerialized\n</code></pre> <p>Builds the HTTP request params needed by the request. :param method: Method to call. :param resource_path: Path to method endpoint. :param path_params: Path parameters in the url. :param query_params: Query parameters in the url. :param header_params: Header parameters to be     placed in the request header. :param body: Request body. :param post_params dict: Request post form parameters,     for <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>. :param auth_settings list: Auth Settings names for the request. :param files dict: key -&gt; filename, value -&gt; filepath,     for <code>multipart/form-data</code>. :param collection_formats: dict of collection formats for path, query,     header, and post parameters. :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the authentication                       in the spec for a single request. :return: tuple of form (path, http_method, query_params, header_params,     body, post_params, files)</p> Source code in <code>client/src/openapi_client/api_client.py</code> <pre><code>def param_serialize(\n    self,\n    method,\n    resource_path,\n    path_params=None,\n    query_params=None,\n    header_params=None,\n    body=None,\n    post_params=None,\n    files=None,\n    auth_settings=None,\n    collection_formats=None,\n    _host=None,\n    _request_auth=None,\n) -&gt; RequestSerialized:\n    \"\"\"Builds the HTTP request params needed by the request.\n    :param method: Method to call.\n    :param resource_path: Path to method endpoint.\n    :param path_params: Path parameters in the url.\n    :param query_params: Query parameters in the url.\n    :param header_params: Header parameters to be\n        placed in the request header.\n    :param body: Request body.\n    :param post_params dict: Request post form parameters,\n        for `application/x-www-form-urlencoded`, `multipart/form-data`.\n    :param auth_settings list: Auth Settings names for the request.\n    :param files dict: key -&gt; filename, value -&gt; filepath,\n        for `multipart/form-data`.\n    :param collection_formats: dict of collection formats for path, query,\n        header, and post parameters.\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the authentication\n                          in the spec for a single request.\n    :return: tuple of form (path, http_method, query_params, header_params,\n        body, post_params, files)\n    \"\"\"\n\n    config = self.configuration\n\n    # header parameters\n    header_params = header_params or {}\n    header_params.update(self.default_headers)\n    if self.cookie:\n        header_params[\"Cookie\"] = self.cookie\n    if header_params:\n        header_params = self.sanitize_for_serialization(header_params)\n        header_params = dict(\n            self.parameters_to_tuples(header_params, collection_formats)\n        )\n\n    # path parameters\n    if path_params:\n        path_params = self.sanitize_for_serialization(path_params)\n        path_params = self.parameters_to_tuples(path_params, collection_formats)\n        for k, v in path_params:\n            # specified safe chars, encode everything\n            resource_path = resource_path.replace(\n                f\"{{{k}}}\", quote(str(v), safe=config.safe_chars_for_path_param)\n            )\n\n    # post parameters\n    if post_params or files:\n        post_params = post_params if post_params else []\n        post_params = self.sanitize_for_serialization(post_params)\n        post_params = self.parameters_to_tuples(post_params, collection_formats)\n        if files:\n            post_params.extend(self.files_parameters(files))\n\n    # auth setting\n    self.update_params_for_auth(\n        header_params,\n        query_params,\n        auth_settings,\n        resource_path,\n        method,\n        body,\n        request_auth=_request_auth,\n    )\n\n    # body\n    if body:\n        body = self.sanitize_for_serialization(body)\n\n    # request url\n    if _host is None or self.configuration.ignore_operation_servers:\n        url = self.configuration.host + resource_path\n    else:\n        # use server/host defined in path or operation instead\n        url = _host + resource_path\n\n    # query parameters\n    if query_params:\n        query_params = self.sanitize_for_serialization(query_params)\n        url_query = self.parameters_to_url_query(query_params, collection_formats)\n        url += \"?\" + url_query\n\n    return method, url, header_params, body, post_params\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.call_api","title":"call_api","text":"<pre><code>call_api(\n    method, url, header_params=None, body=None, post_params=None, _request_timeout=None\n) -&gt; RESTResponse\n</code></pre> <p>Makes the HTTP request (synchronous) :param method: Method to call. :param url: Path to method endpoint. :param header_params: Header parameters to be     placed in the request header. :param body: Request body. :param post_params dict: Request post form parameters,     for <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>. :param _request_timeout: timeout setting for this request. :return: RESTResponse</p> Source code in <code>client/src/openapi_client/api_client.py</code> <pre><code>def call_api(\n    self,\n    method,\n    url,\n    header_params=None,\n    body=None,\n    post_params=None,\n    _request_timeout=None,\n) -&gt; rest.RESTResponse:\n    \"\"\"Makes the HTTP request (synchronous)\n    :param method: Method to call.\n    :param url: Path to method endpoint.\n    :param header_params: Header parameters to be\n        placed in the request header.\n    :param body: Request body.\n    :param post_params dict: Request post form parameters,\n        for `application/x-www-form-urlencoded`, `multipart/form-data`.\n    :param _request_timeout: timeout setting for this request.\n    :return: RESTResponse\n    \"\"\"\n\n    try:\n        # perform request and return response\n        response_data = self.rest_client.request(\n            method,\n            url,\n            headers=header_params,\n            body=body,\n            post_params=post_params,\n            _request_timeout=_request_timeout,\n        )\n\n    except ApiException as e:\n        raise e\n\n    return response_data\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.response_deserialize","title":"response_deserialize","text":"<pre><code>response_deserialize(\n    response_data: RESTResponse, response_types_map: dict[str, T] | None = None\n) -&gt; ApiResponse[T]\n</code></pre> <p>Deserializes response into an object. :param response_data: RESTResponse object to be deserialized. :param response_types_map: dict of response types. :return: ApiResponse</p> Source code in <code>client/src/openapi_client/api_client.py</code> <pre><code>def response_deserialize(\n    self,\n    response_data: rest.RESTResponse,\n    response_types_map: dict[str, ApiResponseT] | None = None,\n) -&gt; ApiResponse[ApiResponseT]:\n    \"\"\"Deserializes response into an object.\n    :param response_data: RESTResponse object to be deserialized.\n    :param response_types_map: dict of response types.\n    :return: ApiResponse\n    \"\"\"\n\n    msg = \"RESTResponse.read() must be called before passing it to response_deserialize()\"\n    assert response_data.data is not None, msg\n\n    response_type = response_types_map.get(str(response_data.status), None)\n    if (\n        not response_type\n        and isinstance(response_data.status, int)\n        and 100 &lt;= response_data.status &lt;= 599\n    ):\n        # if not found, look for '1XX', '2XX', etc.\n        response_type = response_types_map.get(\n            str(response_data.status)[0] + \"XX\", None\n        )\n\n    # deserialize response data\n    response_text = None\n    return_data = None\n    try:\n        if response_type == \"bytearray\":\n            return_data = response_data.data\n        elif response_type == \"file\":\n            return_data = self.__deserialize_file(response_data)\n        elif response_type is not None:\n            match = None\n            content_type = response_data.getheader(\"content-type\")\n            if content_type is not None:\n                match = re.search(r\"charset=([a-zA-Z\\-\\d]+)[\\s;]?\", content_type)\n            encoding = match.group(1) if match else \"utf-8\"\n            response_text = response_data.data.decode(encoding)\n            return_data = self.deserialize(\n                response_text, response_type, content_type\n            )\n    finally:\n        if not 200 &lt;= response_data.status &lt;= 299:\n            raise ApiException.from_response(\n                http_resp=response_data,\n                body=response_text,\n                data=return_data,\n            )\n\n    return ApiResponse(\n        status_code=response_data.status,\n        data=return_data,\n        headers=response_data.getheaders(),\n        raw_data=response_data.data,\n    )\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.sanitize_for_serialization","title":"sanitize_for_serialization","text":"<pre><code>sanitize_for_serialization(obj)\n</code></pre> <p>Builds a JSON POST object.</p> <p>If obj is None, return None. If obj is SecretStr, return obj.get_secret_value() If obj is str, int, long, float, bool, return directly. If obj is datetime.datetime, datetime.date     convert to string in iso8601 format. If obj is decimal.Decimal return string representation. If obj is list, sanitize each element in the list. If obj is dict, return the dict. If obj is OpenAPI model, return the properties dict.</p> <p>:param obj: The data to serialize. :return: The serialized form of data.</p> Source code in <code>client/src/openapi_client/api_client.py</code> <pre><code>def sanitize_for_serialization(self, obj):\n    \"\"\"Builds a JSON POST object.\n\n    If obj is None, return None.\n    If obj is SecretStr, return obj.get_secret_value()\n    If obj is str, int, long, float, bool, return directly.\n    If obj is datetime.datetime, datetime.date\n        convert to string in iso8601 format.\n    If obj is decimal.Decimal return string representation.\n    If obj is list, sanitize each element in the list.\n    If obj is dict, return the dict.\n    If obj is OpenAPI model, return the properties dict.\n\n    :param obj: The data to serialize.\n    :return: The serialized form of data.\n    \"\"\"\n    if obj is None:\n        return None\n    elif isinstance(obj, Enum):\n        return obj.value\n    elif isinstance(obj, SecretStr):\n        return obj.get_secret_value()\n    elif isinstance(obj, self.PRIMITIVE_TYPES):\n        return obj\n    elif isinstance(obj, list):\n        return [self.sanitize_for_serialization(sub_obj) for sub_obj in obj]\n    elif isinstance(obj, tuple):\n        return tuple(self.sanitize_for_serialization(sub_obj) for sub_obj in obj)\n    elif isinstance(obj, datetime.datetime | datetime.date):\n        return obj.isoformat()\n    elif isinstance(obj, decimal.Decimal):\n        return str(obj)\n\n    elif isinstance(obj, dict):\n        obj_dict = obj\n    else:\n        # Convert model obj to dict except\n        # attributes `openapi_types`, `attribute_map`\n        # and attributes which value is not None.\n        # Convert attribute name to json key in\n        # model definition for request.\n        if hasattr(obj, \"to_dict\") and callable(obj.to_dict):\n            obj_dict = obj.to_dict()\n        else:\n            obj_dict = obj.__dict__\n\n    return {\n        key: self.sanitize_for_serialization(val) for key, val in obj_dict.items()\n    }\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.deserialize","title":"deserialize","text":"<pre><code>deserialize(response_text: str, response_type: str, content_type: str | None)\n</code></pre> <p>Deserializes response into an object.</p> <p>:param response: RESTResponse object to be deserialized. :param response_type: class literal for     deserialized object, or string of class name. :param content_type: content type of response.</p> <p>:return: deserialized object.</p> Source code in <code>client/src/openapi_client/api_client.py</code> <pre><code>def deserialize(\n    self, response_text: str, response_type: str, content_type: str | None\n):\n    \"\"\"Deserializes response into an object.\n\n    :param response: RESTResponse object to be deserialized.\n    :param response_type: class literal for\n        deserialized object, or string of class name.\n    :param content_type: content type of response.\n\n    :return: deserialized object.\n    \"\"\"\n\n    # fetch data from response object\n    if content_type is None:\n        try:\n            data = json.loads(response_text)\n        except ValueError:\n            data = response_text\n    elif re.match(\n        r\"^application/(json|[\\w!#$&amp;.+-^_]+\\+json)\\s*(;|$)\",\n        content_type,\n        re.IGNORECASE,\n    ):\n        if response_text == \"\":\n            data = \"\"\n        else:\n            data = json.loads(response_text)\n    elif re.match(r\"^text/plain\\s*(;|$)\", content_type, re.IGNORECASE):\n        data = response_text\n    else:\n        raise ApiException(\n            status=0, reason=f\"Unsupported content type: {content_type}\"\n        )\n\n    return self.__deserialize(data, response_type)\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.parameters_to_tuples","title":"parameters_to_tuples","text":"<pre><code>parameters_to_tuples(params, collection_formats)\n</code></pre> <p>Get parameters as list of tuples, formatting collections.</p> <p>:param params: Parameters as dict or list of two-tuples :param dict collection_formats: Parameter collection formats :return: Parameters as list of tuples, collections formatted</p> Source code in <code>client/src/openapi_client/api_client.py</code> <pre><code>def parameters_to_tuples(self, params, collection_formats):\n    \"\"\"Get parameters as list of tuples, formatting collections.\n\n    :param params: Parameters as dict or list of two-tuples\n    :param dict collection_formats: Parameter collection formats\n    :return: Parameters as list of tuples, collections formatted\n    \"\"\"\n    new_params: list[tuple[str, str]] = []\n    if collection_formats is None:\n        collection_formats = {}\n    for k, v in params.items() if isinstance(params, dict) else params:\n        if k in collection_formats:\n            collection_format = collection_formats[k]\n            if collection_format == \"multi\":\n                new_params.extend((k, value) for value in v)\n            else:\n                if collection_format == \"ssv\":\n                    delimiter = \" \"\n                elif collection_format == \"tsv\":\n                    delimiter = \"\\t\"\n                elif collection_format == \"pipes\":\n                    delimiter = \"|\"\n                else:  # csv is the default\n                    delimiter = \",\"\n                new_params.append((k, delimiter.join(str(value) for value in v)))\n        else:\n            new_params.append((k, v))\n    return new_params\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.parameters_to_url_query","title":"parameters_to_url_query","text":"<pre><code>parameters_to_url_query(params, collection_formats)\n</code></pre> <p>Get parameters as list of tuples, formatting collections.</p> <p>:param params: Parameters as dict or list of two-tuples :param dict collection_formats: Parameter collection formats :return: URL query string (e.g. a=Hello%20World&amp;b=123)</p> Source code in <code>client/src/openapi_client/api_client.py</code> <pre><code>def parameters_to_url_query(self, params, collection_formats):\n    \"\"\"Get parameters as list of tuples, formatting collections.\n\n    :param params: Parameters as dict or list of two-tuples\n    :param dict collection_formats: Parameter collection formats\n    :return: URL query string (e.g. a=Hello%20World&amp;b=123)\n    \"\"\"\n    new_params: list[tuple[str, str]] = []\n    if collection_formats is None:\n        collection_formats = {}\n    for k, v in params.items() if isinstance(params, dict) else params:\n        if isinstance(v, bool):\n            v = str(v).lower()\n        if isinstance(v, int | float):\n            v = str(v)\n        if isinstance(v, dict):\n            v = json.dumps(v)\n\n        if k in collection_formats:\n            collection_format = collection_formats[k]\n            if collection_format == \"multi\":\n                new_params.extend((k, str(value)) for value in v)\n            else:\n                if collection_format == \"ssv\":\n                    delimiter = \" \"\n                elif collection_format == \"tsv\":\n                    delimiter = \"\\t\"\n                elif collection_format == \"pipes\":\n                    delimiter = \"|\"\n                else:  # csv is the default\n                    delimiter = \",\"\n                new_params.append((\n                    k,\n                    delimiter.join(quote(str(value)) for value in v),\n                ))\n        else:\n            new_params.append((k, quote(str(v))))\n\n    return \"&amp;\".join([\"=\".join(map(str, item)) for item in new_params])\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.files_parameters","title":"files_parameters","text":"<pre><code>files_parameters(files: dict[str, str | bytes | list[str] | list[bytes] | tuple[str, bytes]])\n</code></pre> <p>Builds form parameters.</p> <p>:param files: File parameters. :return: Form parameters with files.</p> Source code in <code>client/src/openapi_client/api_client.py</code> <pre><code>def files_parameters(\n    self,\n    files: dict[str, str | bytes | list[str] | list[bytes] | tuple[str, bytes]],\n):\n    \"\"\"Builds form parameters.\n\n    :param files: File parameters.\n    :return: Form parameters with files.\n    \"\"\"\n    params = []\n    for k, v in files.items():\n        if isinstance(v, str):\n            with open(v, \"rb\") as f:\n                filename = os.path.basename(f.name)\n                filedata = f.read()\n        elif isinstance(v, bytes):\n            filename = k\n            filedata = v\n        elif isinstance(v, tuple):\n            filename, filedata = v\n        elif isinstance(v, list):\n            for file_param in v:\n                params.extend(self.files_parameters({k: file_param}))\n            continue\n        else:\n            raise ValueError(\"Unsupported file value\")\n        mimetype = mimetypes.guess_type(filename)[0] or \"application/octet-stream\"\n        params.append((k, (filename, filedata, mimetype)))\n    return params\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.select_header_accept","title":"select_header_accept","text":"<pre><code>select_header_accept(accepts: list[str]) -&gt; str | None\n</code></pre> <p>Returns <code>Accept</code> based on an array of accepts provided.</p> <p>:param accepts: List of headers. :return: Accept (e.g. application/json).</p> Source code in <code>client/src/openapi_client/api_client.py</code> <pre><code>def select_header_accept(self, accepts: list[str]) -&gt; str | None:\n    \"\"\"Returns `Accept` based on an array of accepts provided.\n\n    :param accepts: List of headers.\n    :return: Accept (e.g. application/json).\n    \"\"\"\n    if not accepts:\n        return None\n\n    for accept in accepts:\n        if re.search(\"json\", accept, re.IGNORECASE):\n            return accept\n\n    return accepts[0]\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.select_header_content_type","title":"select_header_content_type","text":"<pre><code>select_header_content_type(content_types)\n</code></pre> <p>Returns <code>Content-Type</code> based on an array of content_types provided.</p> <p>:param content_types: List of content-types. :return: Content-Type (e.g. application/json).</p> Source code in <code>client/src/openapi_client/api_client.py</code> <pre><code>def select_header_content_type(self, content_types):\n    \"\"\"Returns `Content-Type` based on an array of content_types provided.\n\n    :param content_types: List of content-types.\n    :return: Content-Type (e.g. application/json).\n    \"\"\"\n    if not content_types:\n        return None\n\n    for content_type in content_types:\n        if re.search(\"json\", content_type, re.IGNORECASE):\n            return content_type\n\n    return content_types[0]\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.update_params_for_auth","title":"update_params_for_auth","text":"<pre><code>update_params_for_auth(\n    headers, queries, auth_settings, resource_path, method, body, request_auth=None\n) -&gt; None\n</code></pre> <p>Updates header and query params based on authentication setting.</p> <p>:param headers: Header parameters dict to be updated. :param queries: Query parameters tuple list to be updated. :param auth_settings: Authentication setting identifiers list. :resource_path: A string representation of the HTTP request resource path. :method: A string representation of the HTTP request method. :body: A object representing the body of the HTTP request. The object type is the return value of sanitize_for_serialization(). :param request_auth: if set, the provided settings will                      override the token in the configuration.</p> Source code in <code>client/src/openapi_client/api_client.py</code> <pre><code>def update_params_for_auth(\n    self,\n    headers,\n    queries,\n    auth_settings,\n    resource_path,\n    method,\n    body,\n    request_auth=None,\n) -&gt; None:\n    \"\"\"Updates header and query params based on authentication setting.\n\n    :param headers: Header parameters dict to be updated.\n    :param queries: Query parameters tuple list to be updated.\n    :param auth_settings: Authentication setting identifiers list.\n    :resource_path: A string representation of the HTTP request resource path.\n    :method: A string representation of the HTTP request method.\n    :body: A object representing the body of the HTTP request.\n    The object type is the return value of sanitize_for_serialization().\n    :param request_auth: if set, the provided settings will\n                         override the token in the configuration.\n    \"\"\"\n    if not auth_settings:\n        return\n\n    if request_auth:\n        self._apply_auth_params(\n            headers, queries, resource_path, method, body, request_auth\n        )\n    else:\n        for auth in auth_settings:\n            auth_setting = self.configuration.auth_settings().get(auth)\n            if auth_setting:\n                self._apply_auth_params(\n                    headers, queries, resource_path, method, body, auth_setting\n                )\n</code></pre>"},{"location":"reference/openapi_client/api_response/","title":"api_response","text":"<p>API response object.</p>"},{"location":"reference/openapi_client/api_response/#openapi_client.api_response.ApiResponse","title":"ApiResponse","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[T]</code></p> <p>API response object</p> Source code in <code>client/src/openapi_client/api_response.py</code> <pre><code>class ApiResponse(BaseModel, Generic[T]):\n    \"\"\"\n    API response object\n    \"\"\"\n\n    status_code: StrictInt = Field(description=\"HTTP status code\")\n    headers: Mapping[str, str] | None = Field(None, description=\"HTTP headers\")\n    data: T = Field(description=\"Deserialized data given the data type\")\n    raw_data: StrictBytes = Field(description=\"Raw data (HTTP response body)\")\n\n    model_config = {\"arbitrary_types_allowed\": True}\n</code></pre>"},{"location":"reference/openapi_client/configuration/","title":"configuration","text":"<p>the jobq cluster workflow management tool backend</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration","title":"Configuration","text":"<p>This class contains various settings of the API client.</p> <p>:param host: Base url. :param ignore_operation_servers   Boolean to ignore operation servers for the API client.   Config will use <code>host</code> as the base url regardless of the operation servers. :param api_key: Dict to store API key(s).   Each entry in the dict specifies an API key.   The dict key is the name of the security scheme in the OAS specification.   The dict value is the API key secret. :param api_key_prefix: Dict to store API prefix (e.g. Bearer).   The dict key is the name of the security scheme in the OAS specification.   The dict value is an API key prefix when generating the auth data. :param username: Username for HTTP basic authentication. :param password: Password for HTTP basic authentication. :param access_token: Access token. :param server_index: Index to servers configuration. :param server_variables: Mapping with string values to replace variables in   templated server configuration. The validation of enums is performed for   variables with defined enum values before. :param server_operation_index: Mapping from operation ID to an index to server   configuration. :param server_operation_variables: Mapping from operation ID to a mapping with   string values to replace variables in templated server configuration.   The validation of enums is performed for variables with defined enum   values before. :param ssl_ca_cert: str - the path to a file of concatenated CA certificates   in PEM format. :param retries: Number of retries for API requests.</p> Source code in <code>client/src/openapi_client/configuration.py</code> <pre><code>class Configuration:\n    \"\"\"This class contains various settings of the API client.\n\n    :param host: Base url.\n    :param ignore_operation_servers\n      Boolean to ignore operation servers for the API client.\n      Config will use `host` as the base url regardless of the operation servers.\n    :param api_key: Dict to store API key(s).\n      Each entry in the dict specifies an API key.\n      The dict key is the name of the security scheme in the OAS specification.\n      The dict value is the API key secret.\n    :param api_key_prefix: Dict to store API prefix (e.g. Bearer).\n      The dict key is the name of the security scheme in the OAS specification.\n      The dict value is an API key prefix when generating the auth data.\n    :param username: Username for HTTP basic authentication.\n    :param password: Password for HTTP basic authentication.\n    :param access_token: Access token.\n    :param server_index: Index to servers configuration.\n    :param server_variables: Mapping with string values to replace variables in\n      templated server configuration. The validation of enums is performed for\n      variables with defined enum values before.\n    :param server_operation_index: Mapping from operation ID to an index to server\n      configuration.\n    :param server_operation_variables: Mapping from operation ID to a mapping with\n      string values to replace variables in templated server configuration.\n      The validation of enums is performed for variables with defined enum\n      values before.\n    :param ssl_ca_cert: str - the path to a file of concatenated CA certificates\n      in PEM format.\n    :param retries: Number of retries for API requests.\n\n    \"\"\"\n\n    _default = None\n\n    def __init__(\n        self,\n        host=None,\n        api_key=None,\n        api_key_prefix=None,\n        username=None,\n        password=None,\n        access_token=None,\n        server_index=None,\n        server_variables=None,\n        server_operation_index=None,\n        server_operation_variables=None,\n        ignore_operation_servers=False,\n        ssl_ca_cert=None,\n        retries=None,\n        *,\n        debug: bool | None = None,\n    ) -&gt; None:\n        \"\"\"Constructor\"\"\"\n        self._base_path = \"http://localhost\" if host is None else host\n        \"\"\"Default Base url\n        \"\"\"\n        self.server_index = 0 if server_index is None and host is None else server_index\n        self.server_operation_index = server_operation_index or {}\n        \"\"\"Default server index\n        \"\"\"\n        self.server_variables = server_variables or {}\n        self.server_operation_variables = server_operation_variables or {}\n        \"\"\"Default server variables\n        \"\"\"\n        self.ignore_operation_servers = ignore_operation_servers\n        \"\"\"Ignore operation servers\n        \"\"\"\n        self.temp_folder_path = None\n        \"\"\"Temp file folder for downloading files\n        \"\"\"\n        # Authentication Settings\n        self.api_key = {}\n        if api_key:\n            self.api_key = api_key\n        \"\"\"dict to store API key(s)\n        \"\"\"\n        self.api_key_prefix = {}\n        if api_key_prefix:\n            self.api_key_prefix = api_key_prefix\n        \"\"\"dict to store API prefix (e.g. Bearer)\n        \"\"\"\n        self.refresh_api_key_hook = None\n        \"\"\"function hook to refresh API key if expired\n        \"\"\"\n        self.username = username\n        \"\"\"Username for HTTP basic authentication\n        \"\"\"\n        self.password = password\n        \"\"\"Password for HTTP basic authentication\n        \"\"\"\n        self.access_token = access_token\n        \"\"\"Access token\n        \"\"\"\n        self.logger = {}\n        \"\"\"Logging Settings\n        \"\"\"\n        self.logger[\"package_logger\"] = logging.getLogger(\"openapi_client\")\n        self.logger[\"urllib3_logger\"] = logging.getLogger(\"urllib3\")\n        self.logger_format = \"%(asctime)s %(levelname)s %(message)s\"\n        \"\"\"Log format\n        \"\"\"\n        self.logger_stream_handler = None\n        \"\"\"Log stream handler\n        \"\"\"\n        self.logger_file_handler: FileHandler | None = None\n        \"\"\"Log file handler\n        \"\"\"\n        self.logger_file = None\n        \"\"\"Debug file location\n        \"\"\"\n        if debug is not None:\n            self.debug = debug\n        else:\n            self.__debug = False\n        \"\"\"Debug switch\n        \"\"\"\n\n        self.verify_ssl = True\n        \"\"\"SSL/TLS verification\n           Set this to false to skip verifying SSL certificate when calling API\n           from https server.\n        \"\"\"\n        self.ssl_ca_cert = ssl_ca_cert\n        \"\"\"Set this to customize the certificate file to verify the peer.\n        \"\"\"\n        self.cert_file = None\n        \"\"\"client certificate file\n        \"\"\"\n        self.key_file = None\n        \"\"\"client key file\n        \"\"\"\n        self.assert_hostname = None\n        \"\"\"Set this to True/False to enable/disable SSL hostname verification.\n        \"\"\"\n        self.tls_server_name = None\n        \"\"\"SSL/TLS Server Name Indication (SNI)\n           Set this to the SNI value expected by the server.\n        \"\"\"\n\n        self.connection_pool_maxsize = multiprocessing.cpu_count() * 5\n        \"\"\"urllib3 connection pool's maximum number of connections saved\n           per pool. urllib3 uses 1 connection as default value, but this is\n           not the best value when you are making a lot of possibly parallel\n           requests to the same host, which is often the case here.\n           cpu_count * 5 is used as default value to increase performance.\n        \"\"\"\n\n        self.proxy: str | None = None\n        \"\"\"Proxy URL\n        \"\"\"\n        self.proxy_headers = None\n        \"\"\"Proxy headers\n        \"\"\"\n        self.safe_chars_for_path_param = \"\"\n        \"\"\"Safe chars for path_param\n        \"\"\"\n        self.retries = retries\n        \"\"\"Adding retries to override urllib3 default value 3\n        \"\"\"\n        # Enable client side validation\n        self.client_side_validation = True\n\n        self.socket_options = None\n        \"\"\"Options to pass down to the underlying urllib3 socket\n        \"\"\"\n\n        self.datetime_format = \"%Y-%m-%dT%H:%M:%S.%f%z\"\n        \"\"\"datetime format\n        \"\"\"\n\n        self.date_format = \"%Y-%m-%d\"\n        \"\"\"date format\n        \"\"\"\n\n    def __deepcopy__(self, memo):\n        cls = self.__class__\n        result = cls.__new__(cls)\n        memo[id(self)] = result\n        for k, v in self.__dict__.items():\n            if k not in (\"logger\", \"logger_file_handler\"):\n                setattr(result, k, copy.deepcopy(v, memo))\n        # shallow copy of loggers\n        result.logger = copy.copy(self.logger)\n        # use setters to configure loggers\n        result.logger_file = self.logger_file\n        result.debug = self.debug\n        return result\n\n    def __setattr__(self, name, value):\n        object.__setattr__(self, name, value)\n\n    @classmethod\n    def set_default(cls, default):\n        \"\"\"Set default instance of configuration.\n\n        It stores default configuration, which can be\n        returned by get_default_copy method.\n\n        :param default: object of Configuration\n        \"\"\"\n        cls._default = default\n\n    @classmethod\n    def get_default_copy(cls):\n        \"\"\"Deprecated. Please use `get_default` instead.\n\n        Deprecated. Please use `get_default` instead.\n\n        :return: The configuration object.\n        \"\"\"\n        return cls.get_default()\n\n    @classmethod\n    def get_default(cls):\n        \"\"\"Return the default configuration.\n\n        This method returns newly created, based on default constructor,\n        object of Configuration class or returns a copy of default\n        configuration.\n\n        :return: The configuration object.\n        \"\"\"\n        if cls._default is None:\n            cls._default = Configuration()\n        return cls._default\n\n    @property\n    def logger_file(self):\n        \"\"\"The logger file.\n\n        If the logger_file is None, then add stream handler and remove file\n        handler. Otherwise, add file handler and remove stream handler.\n\n        :param value: The logger_file path.\n        :type: str\n        \"\"\"\n        return self.__logger_file\n\n    @logger_file.setter\n    def logger_file(self, value):\n        \"\"\"The logger file.\n\n        If the logger_file is None, then add stream handler and remove file\n        handler. Otherwise, add file handler and remove stream handler.\n\n        :param value: The logger_file path.\n        :type: str\n        \"\"\"\n        self.__logger_file = value\n        if self.__logger_file:\n            # If set logging file,\n            # then add file handler and remove stream handler.\n            self.logger_file_handler = logging.FileHandler(self.__logger_file)\n            self.logger_file_handler.setFormatter(self.logger_formatter)\n            for _, logger in self.logger.items():\n                logger.addHandler(self.logger_file_handler)\n\n    @property\n    def debug(self):\n        \"\"\"Debug status\n\n        :param value: The debug status, True or False.\n        :type: bool\n        \"\"\"\n        return self.__debug\n\n    @debug.setter\n    def debug(self, value):\n        \"\"\"Debug status\n\n        :param value: The debug status, True or False.\n        :type: bool\n        \"\"\"\n        self.__debug = value\n        if self.__debug:\n            # if debug status is True, turn on debug logging\n            for _, logger in self.logger.items():\n                logger.setLevel(logging.DEBUG)\n            # turn on httplib debug\n            httplib.HTTPConnection.debuglevel = 1\n        else:\n            # if debug status is False, turn off debug logging,\n            # setting log level to default `logging.WARNING`\n            for _, logger in self.logger.items():\n                logger.setLevel(logging.WARNING)\n            # turn off httplib debug\n            httplib.HTTPConnection.debuglevel = 0\n\n    @property\n    def logger_format(self):\n        \"\"\"The logger format.\n\n        The logger_formatter will be updated when sets logger_format.\n\n        :param value: The format string.\n        :type: str\n        \"\"\"\n        return self.__logger_format\n\n    @logger_format.setter\n    def logger_format(self, value):\n        \"\"\"The logger format.\n\n        The logger_formatter will be updated when sets logger_format.\n\n        :param value: The format string.\n        :type: str\n        \"\"\"\n        self.__logger_format = value\n        self.logger_formatter = logging.Formatter(self.__logger_format)\n\n    def get_api_key_with_prefix(self, identifier, alias=None):\n        \"\"\"Gets API key (with prefix if set).\n\n        :param identifier: The identifier of apiKey.\n        :param alias: The alternative identifier of apiKey.\n        :return: The token for api key authentication.\n        \"\"\"\n        if self.refresh_api_key_hook is not None:\n            self.refresh_api_key_hook(self)\n        key = self.api_key.get(\n            identifier, self.api_key.get(alias) if alias is not None else None\n        )\n        if key:\n            prefix = self.api_key_prefix.get(identifier)\n            if prefix:\n                return f\"{prefix} {key}\"\n            else:\n                return key\n\n    def get_basic_auth_token(self):\n        \"\"\"Gets HTTP basic authentication header (string).\n\n        :return: The token for basic HTTP authentication.\n        \"\"\"\n        username = \"\"\n        if self.username is not None:\n            username = self.username\n        password = \"\"\n        if self.password is not None:\n            password = self.password\n        return urllib3.util.make_headers(basic_auth=username + \":\" + password).get(\n            \"authorization\"\n        )\n\n    def auth_settings(self):\n        \"\"\"Gets Auth Settings dict for api client.\n\n        :return: The Auth Settings information dict.\n        \"\"\"\n        auth = {}\n        return auth\n\n    def to_debug_report(self):\n        \"\"\"Gets the essential information for debugging.\n\n        :return: The report for debugging.\n        \"\"\"\n        return (\n            \"Python SDK Debug Report:\\n\"\n            f\"OS: {sys.platform}\\n\"\n            f\"Python Version: {sys.version}\\n\"\n            \"Version of the API: 0.1.0\\n\"\n            \"SDK Package Version: 1.0.0\"\n        )\n\n    def get_host_settings(self):\n        \"\"\"Gets an array of host settings\n\n        :return: An array of host settings\n        \"\"\"\n        return [\n            {\n                \"url\": \"\",\n                \"description\": \"No description provided\",\n            }\n        ]\n\n    def get_host_from_settings(self, index, variables=None, servers=None):\n        \"\"\"Gets host URL based on the index and variables\n        :param index: array index of the host settings\n        :param variables: hash of variable and the corresponding value\n        :param servers: an array of host settings or None\n        :return: URL based on host settings\n        \"\"\"\n        if index is None:\n            return self._base_path\n\n        variables = {} if variables is None else variables\n        servers = self.get_host_settings() if servers is None else servers\n\n        try:\n            server = servers[index]\n        except IndexError:\n            raise ValueError(\n                f\"Invalid index {index} when selecting the host settings. \"\n                f\"Must be less than {len(servers)}\"\n            )\n\n        url = server[\"url\"]\n\n        # go through variables and replace placeholders\n        for variable_name, variable in server.get(\"variables\", {}).items():\n            used_value = variables.get(variable_name, variable[\"default_value\"])\n\n            if \"enum_values\" in variable and used_value not in variable[\"enum_values\"]:\n                raise ValueError(\n                    \"The variable `{}` in the host URL has invalid value \"\n                    \"{}. Must be {}.\".format(\n                        variable_name, variables[variable_name], variable[\"enum_values\"]\n                    )\n                )\n\n            url = url.replace(\"{\" + variable_name + \"}\", used_value)\n\n        return url\n\n    @property\n    def host(self):\n        \"\"\"Return generated host.\"\"\"\n        return self.get_host_from_settings(\n            self.server_index, variables=self.server_variables\n        )\n\n    @host.setter\n    def host(self, value):\n        \"\"\"Fix base path.\"\"\"\n        self._base_path = value\n        self.server_index = None\n</code></pre>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.server_operation_index","title":"server_operation_index  <code>instance-attribute</code>","text":"<pre><code>server_operation_index = server_operation_index or {}\n</code></pre> <p>Default server index</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.server_operation_variables","title":"server_operation_variables  <code>instance-attribute</code>","text":"<pre><code>server_operation_variables = server_operation_variables or {}\n</code></pre> <p>Default server variables</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.ignore_operation_servers","title":"ignore_operation_servers  <code>instance-attribute</code>","text":"<pre><code>ignore_operation_servers = ignore_operation_servers\n</code></pre> <p>Ignore operation servers</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.temp_folder_path","title":"temp_folder_path  <code>instance-attribute</code>","text":"<pre><code>temp_folder_path = None\n</code></pre> <p>Temp file folder for downloading files</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.refresh_api_key_hook","title":"refresh_api_key_hook  <code>instance-attribute</code>","text":"<pre><code>refresh_api_key_hook = None\n</code></pre> <p>function hook to refresh API key if expired</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username = username\n</code></pre> <p>Username for HTTP basic authentication</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password = password\n</code></pre> <p>Password for HTTP basic authentication</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.access_token","title":"access_token  <code>instance-attribute</code>","text":"<pre><code>access_token = access_token\n</code></pre> <p>Access token</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = {}\n</code></pre> <p>Logging Settings</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.logger_stream_handler","title":"logger_stream_handler  <code>instance-attribute</code>","text":"<pre><code>logger_stream_handler = None\n</code></pre> <p>Log stream handler</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.logger_file_handler","title":"logger_file_handler  <code>instance-attribute</code>","text":"<pre><code>logger_file_handler: FileHandler | None = None\n</code></pre> <p>Log file handler</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.verify_ssl","title":"verify_ssl  <code>instance-attribute</code>","text":"<pre><code>verify_ssl = True\n</code></pre> <p>SSL/TLS verification Set this to false to skip verifying SSL certificate when calling API from https server.</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.ssl_ca_cert","title":"ssl_ca_cert  <code>instance-attribute</code>","text":"<pre><code>ssl_ca_cert = ssl_ca_cert\n</code></pre> <p>Set this to customize the certificate file to verify the peer.</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.cert_file","title":"cert_file  <code>instance-attribute</code>","text":"<pre><code>cert_file = None\n</code></pre> <p>client certificate file</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.key_file","title":"key_file  <code>instance-attribute</code>","text":"<pre><code>key_file = None\n</code></pre> <p>client key file</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.assert_hostname","title":"assert_hostname  <code>instance-attribute</code>","text":"<pre><code>assert_hostname = None\n</code></pre> <p>Set this to True/False to enable/disable SSL hostname verification.</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.tls_server_name","title":"tls_server_name  <code>instance-attribute</code>","text":"<pre><code>tls_server_name = None\n</code></pre> <p>SSL/TLS Server Name Indication (SNI) Set this to the SNI value expected by the server.</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.connection_pool_maxsize","title":"connection_pool_maxsize  <code>instance-attribute</code>","text":"<pre><code>connection_pool_maxsize = cpu_count() * 5\n</code></pre> <p>urllib3 connection pool's maximum number of connections saved per pool. urllib3 uses 1 connection as default value, but this is not the best value when you are making a lot of possibly parallel requests to the same host, which is often the case here. cpu_count * 5 is used as default value to increase performance.</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.proxy","title":"proxy  <code>instance-attribute</code>","text":"<pre><code>proxy: str | None = None\n</code></pre> <p>Proxy URL</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.proxy_headers","title":"proxy_headers  <code>instance-attribute</code>","text":"<pre><code>proxy_headers = None\n</code></pre> <p>Proxy headers</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.safe_chars_for_path_param","title":"safe_chars_for_path_param  <code>instance-attribute</code>","text":"<pre><code>safe_chars_for_path_param = ''\n</code></pre> <p>Safe chars for path_param</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.retries","title":"retries  <code>instance-attribute</code>","text":"<pre><code>retries = retries\n</code></pre> <p>Adding retries to override urllib3 default value 3</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.socket_options","title":"socket_options  <code>instance-attribute</code>","text":"<pre><code>socket_options = None\n</code></pre> <p>Options to pass down to the underlying urllib3 socket</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.datetime_format","title":"datetime_format  <code>instance-attribute</code>","text":"<pre><code>datetime_format = '%Y-%m-%dT%H:%M:%S.%f%z'\n</code></pre> <p>datetime format</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.date_format","title":"date_format  <code>instance-attribute</code>","text":"<pre><code>date_format = '%Y-%m-%d'\n</code></pre> <p>date format</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.logger_file","title":"logger_file  <code>property</code> <code>writable</code>","text":"<pre><code>logger_file\n</code></pre> <p>The logger file.</p> <p>If the logger_file is None, then add stream handler and remove file handler. Otherwise, add file handler and remove stream handler.</p> <p>:param value: The logger_file path. :type: str</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.debug","title":"debug  <code>property</code> <code>writable</code>","text":"<pre><code>debug\n</code></pre> <p>Debug status</p> <p>:param value: The debug status, True or False. :type: bool</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.logger_format","title":"logger_format  <code>property</code> <code>writable</code>","text":"<pre><code>logger_format\n</code></pre> <p>The logger format.</p> <p>The logger_formatter will be updated when sets logger_format.</p> <p>:param value: The format string. :type: str</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.host","title":"host  <code>property</code> <code>writable</code>","text":"<pre><code>host\n</code></pre> <p>Return generated host.</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.set_default","title":"set_default  <code>classmethod</code>","text":"<pre><code>set_default(default)\n</code></pre> <p>Set default instance of configuration.</p> <p>It stores default configuration, which can be returned by get_default_copy method.</p> <p>:param default: object of Configuration</p> Source code in <code>client/src/openapi_client/configuration.py</code> <pre><code>@classmethod\ndef set_default(cls, default):\n    \"\"\"Set default instance of configuration.\n\n    It stores default configuration, which can be\n    returned by get_default_copy method.\n\n    :param default: object of Configuration\n    \"\"\"\n    cls._default = default\n</code></pre>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.get_default_copy","title":"get_default_copy  <code>classmethod</code>","text":"<pre><code>get_default_copy()\n</code></pre> <p>Deprecated. Please use <code>get_default</code> instead.</p> <p>Deprecated. Please use <code>get_default</code> instead.</p> <p>:return: The configuration object.</p> Source code in <code>client/src/openapi_client/configuration.py</code> <pre><code>@classmethod\ndef get_default_copy(cls):\n    \"\"\"Deprecated. Please use `get_default` instead.\n\n    Deprecated. Please use `get_default` instead.\n\n    :return: The configuration object.\n    \"\"\"\n    return cls.get_default()\n</code></pre>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.get_default","title":"get_default  <code>classmethod</code>","text":"<pre><code>get_default()\n</code></pre> <p>Return the default configuration.</p> <p>This method returns newly created, based on default constructor, object of Configuration class or returns a copy of default configuration.</p> <p>:return: The configuration object.</p> Source code in <code>client/src/openapi_client/configuration.py</code> <pre><code>@classmethod\ndef get_default(cls):\n    \"\"\"Return the default configuration.\n\n    This method returns newly created, based on default constructor,\n    object of Configuration class or returns a copy of default\n    configuration.\n\n    :return: The configuration object.\n    \"\"\"\n    if cls._default is None:\n        cls._default = Configuration()\n    return cls._default\n</code></pre>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.get_api_key_with_prefix","title":"get_api_key_with_prefix","text":"<pre><code>get_api_key_with_prefix(identifier, alias=None)\n</code></pre> <p>Gets API key (with prefix if set).</p> <p>:param identifier: The identifier of apiKey. :param alias: The alternative identifier of apiKey. :return: The token for api key authentication.</p> Source code in <code>client/src/openapi_client/configuration.py</code> <pre><code>def get_api_key_with_prefix(self, identifier, alias=None):\n    \"\"\"Gets API key (with prefix if set).\n\n    :param identifier: The identifier of apiKey.\n    :param alias: The alternative identifier of apiKey.\n    :return: The token for api key authentication.\n    \"\"\"\n    if self.refresh_api_key_hook is not None:\n        self.refresh_api_key_hook(self)\n    key = self.api_key.get(\n        identifier, self.api_key.get(alias) if alias is not None else None\n    )\n    if key:\n        prefix = self.api_key_prefix.get(identifier)\n        if prefix:\n            return f\"{prefix} {key}\"\n        else:\n            return key\n</code></pre>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.get_basic_auth_token","title":"get_basic_auth_token","text":"<pre><code>get_basic_auth_token()\n</code></pre> <p>Gets HTTP basic authentication header (string).</p> <p>:return: The token for basic HTTP authentication.</p> Source code in <code>client/src/openapi_client/configuration.py</code> <pre><code>def get_basic_auth_token(self):\n    \"\"\"Gets HTTP basic authentication header (string).\n\n    :return: The token for basic HTTP authentication.\n    \"\"\"\n    username = \"\"\n    if self.username is not None:\n        username = self.username\n    password = \"\"\n    if self.password is not None:\n        password = self.password\n    return urllib3.util.make_headers(basic_auth=username + \":\" + password).get(\n        \"authorization\"\n    )\n</code></pre>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.auth_settings","title":"auth_settings","text":"<pre><code>auth_settings()\n</code></pre> <p>Gets Auth Settings dict for api client.</p> <p>:return: The Auth Settings information dict.</p> Source code in <code>client/src/openapi_client/configuration.py</code> <pre><code>def auth_settings(self):\n    \"\"\"Gets Auth Settings dict for api client.\n\n    :return: The Auth Settings information dict.\n    \"\"\"\n    auth = {}\n    return auth\n</code></pre>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.to_debug_report","title":"to_debug_report","text":"<pre><code>to_debug_report()\n</code></pre> <p>Gets the essential information for debugging.</p> <p>:return: The report for debugging.</p> Source code in <code>client/src/openapi_client/configuration.py</code> <pre><code>def to_debug_report(self):\n    \"\"\"Gets the essential information for debugging.\n\n    :return: The report for debugging.\n    \"\"\"\n    return (\n        \"Python SDK Debug Report:\\n\"\n        f\"OS: {sys.platform}\\n\"\n        f\"Python Version: {sys.version}\\n\"\n        \"Version of the API: 0.1.0\\n\"\n        \"SDK Package Version: 1.0.0\"\n    )\n</code></pre>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.get_host_settings","title":"get_host_settings","text":"<pre><code>get_host_settings()\n</code></pre> <p>Gets an array of host settings</p> <p>:return: An array of host settings</p> Source code in <code>client/src/openapi_client/configuration.py</code> <pre><code>def get_host_settings(self):\n    \"\"\"Gets an array of host settings\n\n    :return: An array of host settings\n    \"\"\"\n    return [\n        {\n            \"url\": \"\",\n            \"description\": \"No description provided\",\n        }\n    ]\n</code></pre>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.get_host_from_settings","title":"get_host_from_settings","text":"<pre><code>get_host_from_settings(index, variables=None, servers=None)\n</code></pre> <p>Gets host URL based on the index and variables :param index: array index of the host settings :param variables: hash of variable and the corresponding value :param servers: an array of host settings or None :return: URL based on host settings</p> Source code in <code>client/src/openapi_client/configuration.py</code> <pre><code>def get_host_from_settings(self, index, variables=None, servers=None):\n    \"\"\"Gets host URL based on the index and variables\n    :param index: array index of the host settings\n    :param variables: hash of variable and the corresponding value\n    :param servers: an array of host settings or None\n    :return: URL based on host settings\n    \"\"\"\n    if index is None:\n        return self._base_path\n\n    variables = {} if variables is None else variables\n    servers = self.get_host_settings() if servers is None else servers\n\n    try:\n        server = servers[index]\n    except IndexError:\n        raise ValueError(\n            f\"Invalid index {index} when selecting the host settings. \"\n            f\"Must be less than {len(servers)}\"\n        )\n\n    url = server[\"url\"]\n\n    # go through variables and replace placeholders\n    for variable_name, variable in server.get(\"variables\", {}).items():\n        used_value = variables.get(variable_name, variable[\"default_value\"])\n\n        if \"enum_values\" in variable and used_value not in variable[\"enum_values\"]:\n            raise ValueError(\n                \"The variable `{}` in the host URL has invalid value \"\n                \"{}. Must be {}.\".format(\n                    variable_name, variables[variable_name], variable[\"enum_values\"]\n                )\n            )\n\n        url = url.replace(\"{\" + variable_name + \"}\", used_value)\n\n    return url\n</code></pre>"},{"location":"reference/openapi_client/exceptions/","title":"exceptions","text":"<p>the jobq cluster workflow management tool backend</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/exceptions/#openapi_client.exceptions.OpenApiException","title":"OpenApiException","text":"<p>               Bases: <code>Exception</code></p> <p>The base exception class for all OpenAPIExceptions</p> Source code in <code>client/src/openapi_client/exceptions.py</code> <pre><code>class OpenApiException(Exception):\n    \"\"\"The base exception class for all OpenAPIExceptions\"\"\"\n</code></pre>"},{"location":"reference/openapi_client/exceptions/#openapi_client.exceptions.ApiTypeError","title":"ApiTypeError","text":"<p>               Bases: <code>OpenApiException</code>, <code>TypeError</code></p> Source code in <code>client/src/openapi_client/exceptions.py</code> <pre><code>class ApiTypeError(OpenApiException, TypeError):\n    def __init__(\n        self, msg, path_to_item=None, valid_classes=None, key_type=None\n    ) -&gt; None:\n        \"\"\"Raises an exception for TypeErrors\n\n        Args:\n            msg (str): the exception message\n\n        Keyword Args:\n            path_to_item (list): a list of keys an indices to get to the\n                                 current_item\n                                 None if unset\n            valid_classes (tuple): the primitive classes that current item\n                                   should be an instance of\n                                   None if unset\n            key_type (bool): False if our value is a value in a dict\n                             True if it is a key in a dict\n                             False if our item is an item in a list\n                             None if unset\n        \"\"\"\n        self.path_to_item = path_to_item\n        self.valid_classes = valid_classes\n        self.key_type = key_type\n        full_msg = msg\n        if path_to_item:\n            full_msg = f\"{msg} at {render_path(path_to_item)}\"\n        super().__init__(full_msg)\n</code></pre>"},{"location":"reference/openapi_client/exceptions/#openapi_client.exceptions.ApiValueError","title":"ApiValueError","text":"<p>               Bases: <code>OpenApiException</code>, <code>ValueError</code></p> Source code in <code>client/src/openapi_client/exceptions.py</code> <pre><code>class ApiValueError(OpenApiException, ValueError):\n    def __init__(self, msg, path_to_item=None) -&gt; None:\n        \"\"\"\n        Args:\n            msg (str): the exception message\n\n        Keyword Args:\n            path_to_item (list) the path to the exception in the\n                received_data dict. None if unset\n        \"\"\"\n\n        self.path_to_item = path_to_item\n        full_msg = msg\n        if path_to_item:\n            full_msg = f\"{msg} at {render_path(path_to_item)}\"\n        super().__init__(full_msg)\n</code></pre>"},{"location":"reference/openapi_client/exceptions/#openapi_client.exceptions.ApiAttributeError","title":"ApiAttributeError","text":"<p>               Bases: <code>OpenApiException</code>, <code>AttributeError</code></p> Source code in <code>client/src/openapi_client/exceptions.py</code> <pre><code>class ApiAttributeError(OpenApiException, AttributeError):\n    def __init__(self, msg, path_to_item=None) -&gt; None:\n        \"\"\"\n        Raised when an attribute reference or assignment fails.\n\n        Args:\n            msg (str): the exception message\n\n        Keyword Args:\n            path_to_item (None/list) the path to the exception in the\n                received_data dict\n        \"\"\"\n        self.path_to_item = path_to_item\n        full_msg = msg\n        if path_to_item:\n            full_msg = f\"{msg} at {render_path(path_to_item)}\"\n        super().__init__(full_msg)\n</code></pre>"},{"location":"reference/openapi_client/exceptions/#openapi_client.exceptions.ApiKeyError","title":"ApiKeyError","text":"<p>               Bases: <code>OpenApiException</code>, <code>KeyError</code></p> Source code in <code>client/src/openapi_client/exceptions.py</code> <pre><code>class ApiKeyError(OpenApiException, KeyError):\n    def __init__(self, msg, path_to_item=None) -&gt; None:\n        \"\"\"\n        Args:\n            msg (str): the exception message\n\n        Keyword Args:\n            path_to_item (None/list) the path to the exception in the\n                received_data dict\n        \"\"\"\n        self.path_to_item = path_to_item\n        full_msg = msg\n        if path_to_item:\n            full_msg = f\"{msg} at {render_path(path_to_item)}\"\n        super().__init__(full_msg)\n</code></pre>"},{"location":"reference/openapi_client/exceptions/#openapi_client.exceptions.ApiException","title":"ApiException","text":"<p>               Bases: <code>OpenApiException</code></p> Source code in <code>client/src/openapi_client/exceptions.py</code> <pre><code>class ApiException(OpenApiException):\n    def __init__(\n        self,\n        status=None,\n        reason=None,\n        http_resp=None,\n        *,\n        body: str | None = None,\n        data: Any | None = None,\n    ) -&gt; None:\n        self.status = status\n        self.reason = reason\n        self.body = body\n        self.data = data\n        self.headers = None\n\n        if http_resp:\n            if self.status is None:\n                self.status = http_resp.status\n            if self.reason is None:\n                self.reason = http_resp.reason\n            if self.body is None:\n                try:\n                    self.body = http_resp.data.decode(\"utf-8\")\n                except Exception:\n                    pass\n            self.headers = http_resp.getheaders()\n\n    @classmethod\n    def from_response(\n        cls,\n        *,\n        http_resp,\n        body: str | None,\n        data: Any | None,\n    ) -&gt; Self:\n        if http_resp.status == 400:\n            raise BadRequestException(http_resp=http_resp, body=body, data=data)\n\n        if http_resp.status == 401:\n            raise UnauthorizedException(http_resp=http_resp, body=body, data=data)\n\n        if http_resp.status == 403:\n            raise ForbiddenException(http_resp=http_resp, body=body, data=data)\n\n        if http_resp.status == 404:\n            raise NotFoundException(http_resp=http_resp, body=body, data=data)\n\n        if 500 &lt;= http_resp.status &lt;= 599:\n            raise ServiceException(http_resp=http_resp, body=body, data=data)\n        raise ApiException(http_resp=http_resp, body=body, data=data)\n\n    def __str__(self):\n        \"\"\"Custom error messages for exception\"\"\"\n        error_message = f\"({self.status})\\n\" f\"Reason: {self.reason}\\n\"\n        if self.headers:\n            error_message += f\"HTTP response headers: {self.headers}\\n\"\n\n        if self.data or self.body:\n            error_message += f\"HTTP response body: {self.data or self.body}\\n\"\n\n        return error_message\n</code></pre>"},{"location":"reference/openapi_client/exceptions/#openapi_client.exceptions.render_path","title":"render_path","text":"<pre><code>render_path(path_to_item)\n</code></pre> <p>Returns a string representation of a path</p> Source code in <code>client/src/openapi_client/exceptions.py</code> <pre><code>def render_path(path_to_item):\n    \"\"\"Returns a string representation of a path\"\"\"\n    result = \"\"\n    for pth in path_to_item:\n        if isinstance(pth, int):\n            result += f\"[{pth}]\"\n        else:\n            result += f\"['{pth}']\"\n    return result\n</code></pre>"},{"location":"reference/openapi_client/rest/","title":"rest","text":"<p>the jobq cluster workflow management tool backend</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/rest/#openapi_client.rest.RESTResponse","title":"RESTResponse","text":"<p>               Bases: <code>IOBase</code></p> Source code in <code>client/src/openapi_client/rest.py</code> <pre><code>class RESTResponse(io.IOBase):\n    def __init__(self, resp) -&gt; None:\n        self.response = resp\n        self.status = resp.status\n        self.reason = resp.reason\n        self.data = None\n\n    def read(self):\n        if self.data is None:\n            self.data = self.response.data\n        return self.data\n\n    def getheaders(self):\n        \"\"\"Returns a dictionary of the response headers.\"\"\"\n        return self.response.headers\n\n    def getheader(self, name, default=None):\n        \"\"\"Returns a given response header.\"\"\"\n        return self.response.headers.get(name, default)\n</code></pre>"},{"location":"reference/openapi_client/rest/#openapi_client.rest.RESTResponse.getheaders","title":"getheaders","text":"<pre><code>getheaders()\n</code></pre> <p>Returns a dictionary of the response headers.</p> Source code in <code>client/src/openapi_client/rest.py</code> <pre><code>def getheaders(self):\n    \"\"\"Returns a dictionary of the response headers.\"\"\"\n    return self.response.headers\n</code></pre>"},{"location":"reference/openapi_client/rest/#openapi_client.rest.RESTResponse.getheader","title":"getheader","text":"<pre><code>getheader(name, default=None)\n</code></pre> <p>Returns a given response header.</p> Source code in <code>client/src/openapi_client/rest.py</code> <pre><code>def getheader(self, name, default=None):\n    \"\"\"Returns a given response header.\"\"\"\n    return self.response.headers.get(name, default)\n</code></pre>"},{"location":"reference/openapi_client/rest/#openapi_client.rest.RESTClientObject","title":"RESTClientObject","text":"Source code in <code>client/src/openapi_client/rest.py</code> <pre><code>class RESTClientObject:\n    def __init__(self, configuration) -&gt; None:\n        # urllib3.PoolManager will pass all kw parameters to connectionpool\n        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501\n        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501\n        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501\n\n        # cert_reqs\n        if configuration.verify_ssl:\n            cert_reqs = ssl.CERT_REQUIRED\n        else:\n            cert_reqs = ssl.CERT_NONE\n\n        pool_args = {\n            \"cert_reqs\": cert_reqs,\n            \"ca_certs\": configuration.ssl_ca_cert,\n            \"cert_file\": configuration.cert_file,\n            \"key_file\": configuration.key_file,\n        }\n        if configuration.assert_hostname is not None:\n            pool_args[\"assert_hostname\"] = configuration.assert_hostname\n\n        if configuration.retries is not None:\n            pool_args[\"retries\"] = configuration.retries\n\n        if configuration.tls_server_name:\n            pool_args[\"server_hostname\"] = configuration.tls_server_name\n\n        if configuration.socket_options is not None:\n            pool_args[\"socket_options\"] = configuration.socket_options\n\n        if configuration.connection_pool_maxsize is not None:\n            pool_args[\"maxsize\"] = configuration.connection_pool_maxsize\n\n        # https pool manager\n        self.pool_manager: urllib3.PoolManager\n\n        if configuration.proxy:\n            if is_socks_proxy_url(configuration.proxy):\n                from urllib3.contrib.socks import SOCKSProxyManager\n\n                pool_args[\"proxy_url\"] = configuration.proxy\n                pool_args[\"headers\"] = configuration.proxy_headers\n                self.pool_manager = SOCKSProxyManager(**pool_args)\n            else:\n                pool_args[\"proxy_url\"] = configuration.proxy\n                pool_args[\"proxy_headers\"] = configuration.proxy_headers\n                self.pool_manager = urllib3.ProxyManager(**pool_args)\n        else:\n            self.pool_manager = urllib3.PoolManager(**pool_args)\n\n    def request(\n        self,\n        method,\n        url,\n        headers=None,\n        body=None,\n        post_params=None,\n        _request_timeout=None,\n    ):\n        \"\"\"Perform requests.\n\n        :param method: http request method\n        :param url: http request url\n        :param headers: http request headers\n        :param body: request json body, for `application/json`\n        :param post_params: request post parameters,\n                            `application/x-www-form-urlencoded`\n                            and `multipart/form-data`\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        \"\"\"\n        method = method.upper()\n        assert method in [\"GET\", \"HEAD\", \"DELETE\", \"POST\", \"PUT\", \"PATCH\", \"OPTIONS\"]\n\n        if post_params and body:\n            raise ApiValueError(\n                \"body parameter cannot be used with post_params parameter.\"\n            )\n\n        post_params = post_params or {}\n        headers = headers or {}\n\n        timeout = None\n        if _request_timeout:\n            if isinstance(_request_timeout, int | float):\n                timeout = urllib3.Timeout(total=_request_timeout)\n            elif isinstance(_request_timeout, tuple) and len(_request_timeout) == 2:\n                timeout = urllib3.Timeout(\n                    connect=_request_timeout[0], read=_request_timeout[1]\n                )\n\n        try:\n            # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`\n            if method in [\"POST\", \"PUT\", \"PATCH\", \"OPTIONS\", \"DELETE\"]:\n                # no content type provided or payload is json\n                content_type = headers.get(\"Content-Type\")\n                if not content_type or re.search(\"json\", content_type, re.IGNORECASE):\n                    request_body = None\n                    if body is not None:\n                        request_body = json.dumps(body)\n                    r = self.pool_manager.request(\n                        method,\n                        url,\n                        body=request_body,\n                        timeout=timeout,\n                        headers=headers,\n                        preload_content=False,\n                    )\n                elif content_type == \"application/x-www-form-urlencoded\":\n                    r = self.pool_manager.request(\n                        method,\n                        url,\n                        fields=post_params,\n                        encode_multipart=False,\n                        timeout=timeout,\n                        headers=headers,\n                        preload_content=False,\n                    )\n                elif content_type == \"multipart/form-data\":\n                    # must del headers['Content-Type'], or the correct\n                    # Content-Type which generated by urllib3 will be\n                    # overwritten.\n                    del headers[\"Content-Type\"]\n                    # Ensures that dict objects are serialized\n                    post_params = [\n                        (a, json.dumps(b)) if isinstance(b, dict) else (a, b)\n                        for a, b in post_params\n                    ]\n                    r = self.pool_manager.request(\n                        method,\n                        url,\n                        fields=post_params,\n                        encode_multipart=True,\n                        timeout=timeout,\n                        headers=headers,\n                        preload_content=False,\n                    )\n                # Pass a `string` parameter directly in the body to support\n                # other content types than JSON when `body` argument is\n                # provided in serialized form.\n                elif isinstance(body, str) or isinstance(body, bytes):\n                    r = self.pool_manager.request(\n                        method,\n                        url,\n                        body=body,\n                        timeout=timeout,\n                        headers=headers,\n                        preload_content=False,\n                    )\n                elif headers[\"Content-Type\"] == \"text/plain\" and isinstance(body, bool):\n                    request_body = \"true\" if body else \"false\"\n                    r = self.pool_manager.request(\n                        method,\n                        url,\n                        body=request_body,\n                        preload_content=False,\n                        timeout=timeout,\n                        headers=headers,\n                    )\n                else:\n                    # Cannot generate the request from given parameters\n                    msg = \"\"\"Cannot prepare a request message for provided\n                             arguments. Please check that your arguments match\n                             declared content type.\"\"\"\n                    raise ApiException(status=0, reason=msg)\n            # For `GET`, `HEAD`\n            else:\n                r = self.pool_manager.request(\n                    method,\n                    url,\n                    fields={},\n                    timeout=timeout,\n                    headers=headers,\n                    preload_content=False,\n                )\n        except urllib3.exceptions.SSLError as e:\n            msg = \"\\n\".join([type(e).__name__, str(e)])\n            raise ApiException(status=0, reason=msg)\n\n        return RESTResponse(r)\n</code></pre>"},{"location":"reference/openapi_client/rest/#openapi_client.rest.RESTClientObject.request","title":"request","text":"<pre><code>request(method, url, headers=None, body=None, post_params=None, _request_timeout=None)\n</code></pre> <p>Perform requests.</p> <p>:param method: http request method :param url: http request url :param headers: http request headers :param body: request json body, for <code>application/json</code> :param post_params: request post parameters,                     <code>application/x-www-form-urlencoded</code>                     and <code>multipart/form-data</code> :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts.</p> Source code in <code>client/src/openapi_client/rest.py</code> <pre><code>def request(\n    self,\n    method,\n    url,\n    headers=None,\n    body=None,\n    post_params=None,\n    _request_timeout=None,\n):\n    \"\"\"Perform requests.\n\n    :param method: http request method\n    :param url: http request url\n    :param headers: http request headers\n    :param body: request json body, for `application/json`\n    :param post_params: request post parameters,\n                        `application/x-www-form-urlencoded`\n                        and `multipart/form-data`\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    \"\"\"\n    method = method.upper()\n    assert method in [\"GET\", \"HEAD\", \"DELETE\", \"POST\", \"PUT\", \"PATCH\", \"OPTIONS\"]\n\n    if post_params and body:\n        raise ApiValueError(\n            \"body parameter cannot be used with post_params parameter.\"\n        )\n\n    post_params = post_params or {}\n    headers = headers or {}\n\n    timeout = None\n    if _request_timeout:\n        if isinstance(_request_timeout, int | float):\n            timeout = urllib3.Timeout(total=_request_timeout)\n        elif isinstance(_request_timeout, tuple) and len(_request_timeout) == 2:\n            timeout = urllib3.Timeout(\n                connect=_request_timeout[0], read=_request_timeout[1]\n            )\n\n    try:\n        # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`\n        if method in [\"POST\", \"PUT\", \"PATCH\", \"OPTIONS\", \"DELETE\"]:\n            # no content type provided or payload is json\n            content_type = headers.get(\"Content-Type\")\n            if not content_type or re.search(\"json\", content_type, re.IGNORECASE):\n                request_body = None\n                if body is not None:\n                    request_body = json.dumps(body)\n                r = self.pool_manager.request(\n                    method,\n                    url,\n                    body=request_body,\n                    timeout=timeout,\n                    headers=headers,\n                    preload_content=False,\n                )\n            elif content_type == \"application/x-www-form-urlencoded\":\n                r = self.pool_manager.request(\n                    method,\n                    url,\n                    fields=post_params,\n                    encode_multipart=False,\n                    timeout=timeout,\n                    headers=headers,\n                    preload_content=False,\n                )\n            elif content_type == \"multipart/form-data\":\n                # must del headers['Content-Type'], or the correct\n                # Content-Type which generated by urllib3 will be\n                # overwritten.\n                del headers[\"Content-Type\"]\n                # Ensures that dict objects are serialized\n                post_params = [\n                    (a, json.dumps(b)) if isinstance(b, dict) else (a, b)\n                    for a, b in post_params\n                ]\n                r = self.pool_manager.request(\n                    method,\n                    url,\n                    fields=post_params,\n                    encode_multipart=True,\n                    timeout=timeout,\n                    headers=headers,\n                    preload_content=False,\n                )\n            # Pass a `string` parameter directly in the body to support\n            # other content types than JSON when `body` argument is\n            # provided in serialized form.\n            elif isinstance(body, str) or isinstance(body, bytes):\n                r = self.pool_manager.request(\n                    method,\n                    url,\n                    body=body,\n                    timeout=timeout,\n                    headers=headers,\n                    preload_content=False,\n                )\n            elif headers[\"Content-Type\"] == \"text/plain\" and isinstance(body, bool):\n                request_body = \"true\" if body else \"false\"\n                r = self.pool_manager.request(\n                    method,\n                    url,\n                    body=request_body,\n                    preload_content=False,\n                    timeout=timeout,\n                    headers=headers,\n                )\n            else:\n                # Cannot generate the request from given parameters\n                msg = \"\"\"Cannot prepare a request message for provided\n                         arguments. Please check that your arguments match\n                         declared content type.\"\"\"\n                raise ApiException(status=0, reason=msg)\n        # For `GET`, `HEAD`\n        else:\n            r = self.pool_manager.request(\n                method,\n                url,\n                fields={},\n                timeout=timeout,\n                headers=headers,\n                preload_content=False,\n            )\n    except urllib3.exceptions.SSLError as e:\n        msg = \"\\n\".join([type(e).__name__, str(e)])\n        raise ApiException(status=0, reason=msg)\n\n    return RESTResponse(r)\n</code></pre>"},{"location":"reference/openapi_client/api/","title":"api","text":""},{"location":"reference/openapi_client/api/job_management_api/","title":"job_management_api","text":"<p>the jobq cluster workflow management tool backend</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi","title":"JobManagementApi","text":"<p>NOTE: This class is auto generated by OpenAPI Generator Ref: https://openapi-generator.tech</p> <p>Do not edit the class manually.</p> Source code in <code>client/src/openapi_client/api/job_management_api.py</code> <pre><code>class JobManagementApi:\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n    \"\"\"\n\n    def __init__(self, api_client=None) -&gt; None:\n        if api_client is None:\n            api_client = ApiClient.get_default()\n        self.api_client = api_client\n\n    @validate_call\n    def list_jobs_jobs_get(\n        self,\n        include_metadata: StrictBool | None = None,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; list[ListWorkloadModel]:\n        \"\"\"List Jobs\n\n\n        :param include_metadata:\n        :type include_metadata: bool\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._list_jobs_jobs_get_serialize(\n            include_metadata=include_metadata,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"List[ListWorkloadModel]\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n    @validate_call\n    def list_jobs_jobs_get_with_http_info(\n        self,\n        include_metadata: StrictBool | None = None,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[list[ListWorkloadModel]]:\n        \"\"\"List Jobs\n\n\n        :param include_metadata:\n        :type include_metadata: bool\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._list_jobs_jobs_get_serialize(\n            include_metadata=include_metadata,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"List[ListWorkloadModel]\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n    @validate_call\n    def list_jobs_jobs_get_without_preload_content(\n        self,\n        include_metadata: StrictBool | None = None,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"List Jobs\n\n\n        :param include_metadata:\n        :type include_metadata: bool\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._list_jobs_jobs_get_serialize(\n            include_metadata=include_metadata,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"List[ListWorkloadModel]\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n    def _list_jobs_jobs_get_serialize(\n        self,\n        include_metadata,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; RequestSerialized:\n        _host = None\n\n        _collection_formats: dict[str, str] = {}\n\n        _path_params: dict[str, str] = {}\n        _query_params: list[tuple[str, str]] = []\n        _header_params: dict[str, str | None] = _headers or {}\n        _form_params: list[tuple[str, str]] = []\n        _files: dict[\n            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]\n        ] = {}\n        _body_params: bytes | None = None\n\n        # process the path parameters\n        # process the query parameters\n        if include_metadata is not None:\n            _query_params.append((\"include_metadata\", include_metadata))\n\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n        # set the HTTP header `Accept`\n        if \"Accept\" not in _header_params:\n            _header_params[\"Accept\"] = self.api_client.select_header_accept([\n                \"application/json\"\n            ])\n\n        # authentication setting\n        _auth_settings: list[str] = []\n\n        return self.api_client.param_serialize(\n            method=\"GET\",\n            resource_path=\"/jobs\",\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth,\n        )\n\n    @validate_call\n    def logs_jobs_uid_logs_get(\n        self,\n        uid: StrictStr,\n        namespace: StrictStr | None = None,\n        stream: StrictBool | None = None,\n        tail: Annotated[int, Field(strict=True, ge=-1)] | None = None,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Logs\n\n\n        :param uid: (required)\n        :type uid: str\n        :param namespace:\n        :type namespace: str\n        :param stream:\n        :type stream: bool\n        :param tail:\n        :type tail: int\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._logs_jobs_uid_logs_get_serialize(\n            uid=uid,\n            namespace=namespace,\n            stream=stream,\n            tail=tail,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"object\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n    @validate_call\n    def logs_jobs_uid_logs_get_with_http_info(\n        self,\n        uid: StrictStr,\n        namespace: StrictStr | None = None,\n        stream: StrictBool | None = None,\n        tail: Annotated[int, Field(strict=True, ge=-1)] | None = None,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Logs\n\n\n        :param uid: (required)\n        :type uid: str\n        :param namespace:\n        :type namespace: str\n        :param stream:\n        :type stream: bool\n        :param tail:\n        :type tail: int\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._logs_jobs_uid_logs_get_serialize(\n            uid=uid,\n            namespace=namespace,\n            stream=stream,\n            tail=tail,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"object\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n    @validate_call\n    def logs_jobs_uid_logs_get_without_preload_content(\n        self,\n        uid: StrictStr,\n        namespace: StrictStr | None = None,\n        stream: StrictBool | None = None,\n        tail: Annotated[int, Field(strict=True, ge=-1)] | None = None,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Logs\n\n\n        :param uid: (required)\n        :type uid: str\n        :param namespace:\n        :type namespace: str\n        :param stream:\n        :type stream: bool\n        :param tail:\n        :type tail: int\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._logs_jobs_uid_logs_get_serialize(\n            uid=uid,\n            namespace=namespace,\n            stream=stream,\n            tail=tail,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"object\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n    def _logs_jobs_uid_logs_get_serialize(\n        self,\n        uid,\n        namespace,\n        stream,\n        tail,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; RequestSerialized:\n        _host = None\n\n        _collection_formats: dict[str, str] = {}\n\n        _path_params: dict[str, str] = {}\n        _query_params: list[tuple[str, str]] = []\n        _header_params: dict[str, str | None] = _headers or {}\n        _form_params: list[tuple[str, str]] = []\n        _files: dict[\n            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]\n        ] = {}\n        _body_params: bytes | None = None\n\n        # process the path parameters\n        if uid is not None:\n            _path_params[\"uid\"] = uid\n        # process the query parameters\n        if namespace is not None:\n            _query_params.append((\"namespace\", namespace))\n\n        if stream is not None:\n            _query_params.append((\"stream\", stream))\n\n        if tail is not None:\n            _query_params.append((\"tail\", tail))\n\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n        # set the HTTP header `Accept`\n        if \"Accept\" not in _header_params:\n            _header_params[\"Accept\"] = self.api_client.select_header_accept([\n                \"application/json\"\n            ])\n\n        # authentication setting\n        _auth_settings: list[str] = []\n\n        return self.api_client.param_serialize(\n            method=\"GET\",\n            resource_path=\"/jobs/{uid}/logs\",\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth,\n        )\n\n    @validate_call\n    def status_jobs_uid_status_get(\n        self,\n        uid: StrictStr,\n        namespace: StrictStr | None = None,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; WorkloadMetadata:\n        \"\"\"Status\n\n\n        :param uid: (required)\n        :type uid: str\n        :param namespace:\n        :type namespace: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._status_jobs_uid_status_get_serialize(\n            uid=uid,\n            namespace=namespace,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"WorkloadMetadata\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n    @validate_call\n    def status_jobs_uid_status_get_with_http_info(\n        self,\n        uid: StrictStr,\n        namespace: StrictStr | None = None,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[WorkloadMetadata]:\n        \"\"\"Status\n\n\n        :param uid: (required)\n        :type uid: str\n        :param namespace:\n        :type namespace: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._status_jobs_uid_status_get_serialize(\n            uid=uid,\n            namespace=namespace,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"WorkloadMetadata\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n    @validate_call\n    def status_jobs_uid_status_get_without_preload_content(\n        self,\n        uid: StrictStr,\n        namespace: StrictStr | None = None,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Status\n\n\n        :param uid: (required)\n        :type uid: str\n        :param namespace:\n        :type namespace: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._status_jobs_uid_status_get_serialize(\n            uid=uid,\n            namespace=namespace,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"WorkloadMetadata\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n    def _status_jobs_uid_status_get_serialize(\n        self,\n        uid,\n        namespace,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; RequestSerialized:\n        _host = None\n\n        _collection_formats: dict[str, str] = {}\n\n        _path_params: dict[str, str] = {}\n        _query_params: list[tuple[str, str]] = []\n        _header_params: dict[str, str | None] = _headers or {}\n        _form_params: list[tuple[str, str]] = []\n        _files: dict[\n            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]\n        ] = {}\n        _body_params: bytes | None = None\n\n        # process the path parameters\n        if uid is not None:\n            _path_params[\"uid\"] = uid\n        # process the query parameters\n        if namespace is not None:\n            _query_params.append((\"namespace\", namespace))\n\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n        # set the HTTP header `Accept`\n        if \"Accept\" not in _header_params:\n            _header_params[\"Accept\"] = self.api_client.select_header_accept([\n                \"application/json\"\n            ])\n\n        # authentication setting\n        _auth_settings: list[str] = []\n\n        return self.api_client.param_serialize(\n            method=\"GET\",\n            resource_path=\"/jobs/{uid}/status\",\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth,\n        )\n\n    @validate_call\n    def stop_workload_jobs_uid_stop_post(\n        self,\n        uid: StrictStr,\n        namespace: StrictStr | None = None,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Stop Workload\n\n\n        :param uid: (required)\n        :type uid: str\n        :param namespace:\n        :type namespace: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._stop_workload_jobs_uid_stop_post_serialize(\n            uid=uid,\n            namespace=namespace,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"object\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n    @validate_call\n    def stop_workload_jobs_uid_stop_post_with_http_info(\n        self,\n        uid: StrictStr,\n        namespace: StrictStr | None = None,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Stop Workload\n\n\n        :param uid: (required)\n        :type uid: str\n        :param namespace:\n        :type namespace: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._stop_workload_jobs_uid_stop_post_serialize(\n            uid=uid,\n            namespace=namespace,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"object\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n    @validate_call\n    def stop_workload_jobs_uid_stop_post_without_preload_content(\n        self,\n        uid: StrictStr,\n        namespace: StrictStr | None = None,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Stop Workload\n\n\n        :param uid: (required)\n        :type uid: str\n        :param namespace:\n        :type namespace: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._stop_workload_jobs_uid_stop_post_serialize(\n            uid=uid,\n            namespace=namespace,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"object\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n    def _stop_workload_jobs_uid_stop_post_serialize(\n        self,\n        uid,\n        namespace,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; RequestSerialized:\n        _host = None\n\n        _collection_formats: dict[str, str] = {}\n\n        _path_params: dict[str, str] = {}\n        _query_params: list[tuple[str, str]] = []\n        _header_params: dict[str, str | None] = _headers or {}\n        _form_params: list[tuple[str, str]] = []\n        _files: dict[\n            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]\n        ] = {}\n        _body_params: bytes | None = None\n\n        # process the path parameters\n        if uid is not None:\n            _path_params[\"uid\"] = uid\n        # process the query parameters\n        if namespace is not None:\n            _query_params.append((\"namespace\", namespace))\n\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n        # set the HTTP header `Accept`\n        if \"Accept\" not in _header_params:\n            _header_params[\"Accept\"] = self.api_client.select_header_accept([\n                \"application/json\"\n            ])\n\n        # authentication setting\n        _auth_settings: list[str] = []\n\n        return self.api_client.param_serialize(\n            method=\"POST\",\n            resource_path=\"/jobs/{uid}/stop\",\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth,\n        )\n\n    @validate_call\n    def submit_job_jobs_post(\n        self,\n        create_job_model: CreateJobModel,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; WorkloadIdentifier:\n        \"\"\"Submit Job\n\n\n        :param create_job_model: (required)\n        :type create_job_model: CreateJobModel\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._submit_job_jobs_post_serialize(\n            create_job_model=create_job_model,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"WorkloadIdentifier\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n    @validate_call\n    def submit_job_jobs_post_with_http_info(\n        self,\n        create_job_model: CreateJobModel,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[WorkloadIdentifier]:\n        \"\"\"Submit Job\n\n\n        :param create_job_model: (required)\n        :type create_job_model: CreateJobModel\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._submit_job_jobs_post_serialize(\n            create_job_model=create_job_model,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"WorkloadIdentifier\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n    @validate_call\n    def submit_job_jobs_post_without_preload_content(\n        self,\n        create_job_model: CreateJobModel,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Submit Job\n\n\n        :param create_job_model: (required)\n        :type create_job_model: CreateJobModel\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._submit_job_jobs_post_serialize(\n            create_job_model=create_job_model,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"WorkloadIdentifier\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n    def _submit_job_jobs_post_serialize(\n        self,\n        create_job_model,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; RequestSerialized:\n        _host = None\n\n        _collection_formats: dict[str, str] = {}\n\n        _path_params: dict[str, str] = {}\n        _query_params: list[tuple[str, str]] = []\n        _header_params: dict[str, str | None] = _headers or {}\n        _form_params: list[tuple[str, str]] = []\n        _files: dict[\n            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]\n        ] = {}\n        _body_params: bytes | None = None\n\n        # process the path parameters\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n        if create_job_model is not None:\n            _body_params = create_job_model\n\n        # set the HTTP header `Accept`\n        if \"Accept\" not in _header_params:\n            _header_params[\"Accept\"] = self.api_client.select_header_accept([\n                \"application/json\"\n            ])\n\n        # set the HTTP header `Content-Type`\n        if _content_type:\n            _header_params[\"Content-Type\"] = _content_type\n        else:\n            _default_content_type = self.api_client.select_header_content_type([\n                \"application/json\"\n            ])\n            if _default_content_type is not None:\n                _header_params[\"Content-Type\"] = _default_content_type\n\n        # authentication setting\n        _auth_settings: list[str] = []\n\n        return self.api_client.param_serialize(\n            method=\"POST\",\n            resource_path=\"/jobs\",\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth,\n        )\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.list_jobs_jobs_get","title":"list_jobs_jobs_get","text":"<pre><code>list_jobs_jobs_get(\n    include_metadata: StrictBool | None = None,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; list[ListWorkloadModel]\n</code></pre> <p>List Jobs</p> <p>:param include_metadata: :type include_metadata: bool :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>client/src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef list_jobs_jobs_get(\n    self,\n    include_metadata: StrictBool | None = None,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; list[ListWorkloadModel]:\n    \"\"\"List Jobs\n\n\n    :param include_metadata:\n    :type include_metadata: bool\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._list_jobs_jobs_get_serialize(\n        include_metadata=include_metadata,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"List[ListWorkloadModel]\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.list_jobs_jobs_get_with_http_info","title":"list_jobs_jobs_get_with_http_info","text":"<pre><code>list_jobs_jobs_get_with_http_info(\n    include_metadata: StrictBool | None = None,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[list[ListWorkloadModel]]\n</code></pre> <p>List Jobs</p> <p>:param include_metadata: :type include_metadata: bool :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>client/src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef list_jobs_jobs_get_with_http_info(\n    self,\n    include_metadata: StrictBool | None = None,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[list[ListWorkloadModel]]:\n    \"\"\"List Jobs\n\n\n    :param include_metadata:\n    :type include_metadata: bool\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._list_jobs_jobs_get_serialize(\n        include_metadata=include_metadata,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"List[ListWorkloadModel]\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.list_jobs_jobs_get_without_preload_content","title":"list_jobs_jobs_get_without_preload_content","text":"<pre><code>list_jobs_jobs_get_without_preload_content(\n    include_metadata: StrictBool | None = None,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType\n</code></pre> <p>List Jobs</p> <p>:param include_metadata: :type include_metadata: bool :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>client/src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef list_jobs_jobs_get_without_preload_content(\n    self,\n    include_metadata: StrictBool | None = None,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"List Jobs\n\n\n    :param include_metadata:\n    :type include_metadata: bool\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._list_jobs_jobs_get_serialize(\n        include_metadata=include_metadata,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"List[ListWorkloadModel]\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.logs_jobs_uid_logs_get","title":"logs_jobs_uid_logs_get","text":"<pre><code>logs_jobs_uid_logs_get(\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    stream: StrictBool | None = None,\n    tail: Annotated[int, Field(strict=True, ge=-1)] | None = None,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object\n</code></pre> <p>Logs</p> <p>:param uid: (required) :type uid: str :param namespace: :type namespace: str :param stream: :type stream: bool :param tail: :type tail: int :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>client/src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef logs_jobs_uid_logs_get(\n    self,\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    stream: StrictBool | None = None,\n    tail: Annotated[int, Field(strict=True, ge=-1)] | None = None,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Logs\n\n\n    :param uid: (required)\n    :type uid: str\n    :param namespace:\n    :type namespace: str\n    :param stream:\n    :type stream: bool\n    :param tail:\n    :type tail: int\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._logs_jobs_uid_logs_get_serialize(\n        uid=uid,\n        namespace=namespace,\n        stream=stream,\n        tail=tail,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"object\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.logs_jobs_uid_logs_get_with_http_info","title":"logs_jobs_uid_logs_get_with_http_info","text":"<pre><code>logs_jobs_uid_logs_get_with_http_info(\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    stream: StrictBool | None = None,\n    tail: Annotated[int, Field(strict=True, ge=-1)] | None = None,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]\n</code></pre> <p>Logs</p> <p>:param uid: (required) :type uid: str :param namespace: :type namespace: str :param stream: :type stream: bool :param tail: :type tail: int :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>client/src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef logs_jobs_uid_logs_get_with_http_info(\n    self,\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    stream: StrictBool | None = None,\n    tail: Annotated[int, Field(strict=True, ge=-1)] | None = None,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Logs\n\n\n    :param uid: (required)\n    :type uid: str\n    :param namespace:\n    :type namespace: str\n    :param stream:\n    :type stream: bool\n    :param tail:\n    :type tail: int\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._logs_jobs_uid_logs_get_serialize(\n        uid=uid,\n        namespace=namespace,\n        stream=stream,\n        tail=tail,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"object\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.logs_jobs_uid_logs_get_without_preload_content","title":"logs_jobs_uid_logs_get_without_preload_content","text":"<pre><code>logs_jobs_uid_logs_get_without_preload_content(\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    stream: StrictBool | None = None,\n    tail: Annotated[int, Field(strict=True, ge=-1)] | None = None,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType\n</code></pre> <p>Logs</p> <p>:param uid: (required) :type uid: str :param namespace: :type namespace: str :param stream: :type stream: bool :param tail: :type tail: int :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>client/src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef logs_jobs_uid_logs_get_without_preload_content(\n    self,\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    stream: StrictBool | None = None,\n    tail: Annotated[int, Field(strict=True, ge=-1)] | None = None,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Logs\n\n\n    :param uid: (required)\n    :type uid: str\n    :param namespace:\n    :type namespace: str\n    :param stream:\n    :type stream: bool\n    :param tail:\n    :type tail: int\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._logs_jobs_uid_logs_get_serialize(\n        uid=uid,\n        namespace=namespace,\n        stream=stream,\n        tail=tail,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"object\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.status_jobs_uid_status_get","title":"status_jobs_uid_status_get","text":"<pre><code>status_jobs_uid_status_get(\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; WorkloadMetadata\n</code></pre> <p>Status</p> <p>:param uid: (required) :type uid: str :param namespace: :type namespace: str :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>client/src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef status_jobs_uid_status_get(\n    self,\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; WorkloadMetadata:\n    \"\"\"Status\n\n\n    :param uid: (required)\n    :type uid: str\n    :param namespace:\n    :type namespace: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._status_jobs_uid_status_get_serialize(\n        uid=uid,\n        namespace=namespace,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"WorkloadMetadata\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.status_jobs_uid_status_get_with_http_info","title":"status_jobs_uid_status_get_with_http_info","text":"<pre><code>status_jobs_uid_status_get_with_http_info(\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[WorkloadMetadata]\n</code></pre> <p>Status</p> <p>:param uid: (required) :type uid: str :param namespace: :type namespace: str :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>client/src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef status_jobs_uid_status_get_with_http_info(\n    self,\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[WorkloadMetadata]:\n    \"\"\"Status\n\n\n    :param uid: (required)\n    :type uid: str\n    :param namespace:\n    :type namespace: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._status_jobs_uid_status_get_serialize(\n        uid=uid,\n        namespace=namespace,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"WorkloadMetadata\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.status_jobs_uid_status_get_without_preload_content","title":"status_jobs_uid_status_get_without_preload_content","text":"<pre><code>status_jobs_uid_status_get_without_preload_content(\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType\n</code></pre> <p>Status</p> <p>:param uid: (required) :type uid: str :param namespace: :type namespace: str :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>client/src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef status_jobs_uid_status_get_without_preload_content(\n    self,\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Status\n\n\n    :param uid: (required)\n    :type uid: str\n    :param namespace:\n    :type namespace: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._status_jobs_uid_status_get_serialize(\n        uid=uid,\n        namespace=namespace,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"WorkloadMetadata\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.stop_workload_jobs_uid_stop_post","title":"stop_workload_jobs_uid_stop_post","text":"<pre><code>stop_workload_jobs_uid_stop_post(\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object\n</code></pre> <p>Stop Workload</p> <p>:param uid: (required) :type uid: str :param namespace: :type namespace: str :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>client/src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef stop_workload_jobs_uid_stop_post(\n    self,\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Stop Workload\n\n\n    :param uid: (required)\n    :type uid: str\n    :param namespace:\n    :type namespace: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._stop_workload_jobs_uid_stop_post_serialize(\n        uid=uid,\n        namespace=namespace,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"object\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.stop_workload_jobs_uid_stop_post_with_http_info","title":"stop_workload_jobs_uid_stop_post_with_http_info","text":"<pre><code>stop_workload_jobs_uid_stop_post_with_http_info(\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]\n</code></pre> <p>Stop Workload</p> <p>:param uid: (required) :type uid: str :param namespace: :type namespace: str :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>client/src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef stop_workload_jobs_uid_stop_post_with_http_info(\n    self,\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Stop Workload\n\n\n    :param uid: (required)\n    :type uid: str\n    :param namespace:\n    :type namespace: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._stop_workload_jobs_uid_stop_post_serialize(\n        uid=uid,\n        namespace=namespace,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"object\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.stop_workload_jobs_uid_stop_post_without_preload_content","title":"stop_workload_jobs_uid_stop_post_without_preload_content","text":"<pre><code>stop_workload_jobs_uid_stop_post_without_preload_content(\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType\n</code></pre> <p>Stop Workload</p> <p>:param uid: (required) :type uid: str :param namespace: :type namespace: str :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>client/src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef stop_workload_jobs_uid_stop_post_without_preload_content(\n    self,\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Stop Workload\n\n\n    :param uid: (required)\n    :type uid: str\n    :param namespace:\n    :type namespace: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._stop_workload_jobs_uid_stop_post_serialize(\n        uid=uid,\n        namespace=namespace,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"object\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.submit_job_jobs_post","title":"submit_job_jobs_post","text":"<pre><code>submit_job_jobs_post(\n    create_job_model: CreateJobModel,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; WorkloadIdentifier\n</code></pre> <p>Submit Job</p> <p>:param create_job_model: (required) :type create_job_model: CreateJobModel :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>client/src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef submit_job_jobs_post(\n    self,\n    create_job_model: CreateJobModel,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; WorkloadIdentifier:\n    \"\"\"Submit Job\n\n\n    :param create_job_model: (required)\n    :type create_job_model: CreateJobModel\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._submit_job_jobs_post_serialize(\n        create_job_model=create_job_model,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"WorkloadIdentifier\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.submit_job_jobs_post_with_http_info","title":"submit_job_jobs_post_with_http_info","text":"<pre><code>submit_job_jobs_post_with_http_info(\n    create_job_model: CreateJobModel,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[WorkloadIdentifier]\n</code></pre> <p>Submit Job</p> <p>:param create_job_model: (required) :type create_job_model: CreateJobModel :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>client/src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef submit_job_jobs_post_with_http_info(\n    self,\n    create_job_model: CreateJobModel,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[WorkloadIdentifier]:\n    \"\"\"Submit Job\n\n\n    :param create_job_model: (required)\n    :type create_job_model: CreateJobModel\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._submit_job_jobs_post_serialize(\n        create_job_model=create_job_model,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"WorkloadIdentifier\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.submit_job_jobs_post_without_preload_content","title":"submit_job_jobs_post_without_preload_content","text":"<pre><code>submit_job_jobs_post_without_preload_content(\n    create_job_model: CreateJobModel,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType\n</code></pre> <p>Submit Job</p> <p>:param create_job_model: (required) :type create_job_model: CreateJobModel :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>client/src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef submit_job_jobs_post_without_preload_content(\n    self,\n    create_job_model: CreateJobModel,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Submit Job\n\n\n    :param create_job_model: (required)\n    :type create_job_model: CreateJobModel\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._submit_job_jobs_post_serialize(\n        create_job_model=create_job_model,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"WorkloadIdentifier\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"reference/openapi_client/models/","title":"models","text":"<p>the jobq cluster workflow management tool backend</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/create_job_model/","title":"create_job_model","text":"<p>the jobq cluster workflow management tool backend</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/create_job_model/#openapi_client.models.create_job_model.CreateJobModel","title":"CreateJobModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>CreateJobModel</p> Source code in <code>client/src/openapi_client/models/create_job_model.py</code> <pre><code>class CreateJobModel(BaseModel):\n    \"\"\"\n    CreateJobModel\n    \"\"\"  # noqa: E501\n\n    name: StrictStr\n    file: StrictStr\n    image_ref: StrictStr\n    mode: ExecutionMode\n    options: JobOptions\n    submission_context: dict[str, Any] | None = None\n    __properties: ClassVar[list[str]] = [\n        \"name\",\n        \"file\",\n        \"image_ref\",\n        \"mode\",\n        \"options\",\n        \"submission_context\",\n    ]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of CreateJobModel from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: set[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        # override the default output from pydantic by calling `to_dict()` of options\n        if self.options:\n            _dict[\"options\"] = self.options.to_dict()\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of CreateJobModel from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"name\": obj.get(\"name\"),\n            \"file\": obj.get(\"file\"),\n            \"image_ref\": obj.get(\"image_ref\"),\n            \"mode\": obj.get(\"mode\"),\n            \"options\": JobOptions.from_dict(obj[\"options\"])\n            if obj.get(\"options\") is not None\n            else None,\n            \"submission_context\": obj.get(\"submission_context\"),\n        })\n        return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/create_job_model/#openapi_client.models.create_job_model.CreateJobModel.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/create_job_model.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/openapi_client/models/create_job_model/#openapi_client.models.create_job_model.CreateJobModel.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/create_job_model.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/openapi_client/models/create_job_model/#openapi_client.models.create_job_model.CreateJobModel.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of CreateJobModel from a JSON string</p> Source code in <code>client/src/openapi_client/models/create_job_model.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of CreateJobModel from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/create_job_model/#openapi_client.models.create_job_model.CreateJobModel.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>client/src/openapi_client/models/create_job_model.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: set[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    # override the default output from pydantic by calling `to_dict()` of options\n    if self.options:\n        _dict[\"options\"] = self.options.to_dict()\n    return _dict\n</code></pre>"},{"location":"reference/openapi_client/models/create_job_model/#openapi_client.models.create_job_model.CreateJobModel.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of CreateJobModel from a dict</p> Source code in <code>client/src/openapi_client/models/create_job_model.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of CreateJobModel from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"name\": obj.get(\"name\"),\n        \"file\": obj.get(\"file\"),\n        \"image_ref\": obj.get(\"image_ref\"),\n        \"mode\": obj.get(\"mode\"),\n        \"options\": JobOptions.from_dict(obj[\"options\"])\n        if obj.get(\"options\") is not None\n        else None,\n        \"submission_context\": obj.get(\"submission_context\"),\n    })\n    return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/execution_mode/","title":"execution_mode","text":"<p>the jobq cluster workflow management tool backend</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/execution_mode/#openapi_client.models.execution_mode.ExecutionMode","title":"ExecutionMode","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>ExecutionMode</p> Source code in <code>client/src/openapi_client/models/execution_mode.py</code> <pre><code>class ExecutionMode(str, Enum):\n    \"\"\"\n    ExecutionMode\n    \"\"\"\n\n    \"\"\"\n    allowed enum values\n    \"\"\"\n    LOCAL = \"local\"\n    DOCKER = \"docker\"\n    KUEUE = \"kueue\"\n    RAYJOB = \"rayjob\"\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self:\n        \"\"\"Create an instance of ExecutionMode from a JSON string\"\"\"\n        return cls(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/execution_mode/#openapi_client.models.execution_mode.ExecutionMode.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self\n</code></pre> <p>Create an instance of ExecutionMode from a JSON string</p> Source code in <code>client/src/openapi_client/models/execution_mode.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self:\n    \"\"\"Create an instance of ExecutionMode from a JSON string\"\"\"\n    return cls(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/http_validation_error/","title":"http_validation_error","text":"<p>the jobq cluster workflow management tool backend</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/http_validation_error/#openapi_client.models.http_validation_error.HTTPValidationError","title":"HTTPValidationError","text":"<p>               Bases: <code>BaseModel</code></p> <p>HTTPValidationError</p> Source code in <code>client/src/openapi_client/models/http_validation_error.py</code> <pre><code>class HTTPValidationError(BaseModel):\n    \"\"\"\n    HTTPValidationError\n    \"\"\"  # noqa: E501\n\n    detail: list[ValidationError] | None = None\n    __properties: ClassVar[list[str]] = [\"detail\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of HTTPValidationError from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: set[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        # override the default output from pydantic by calling `to_dict()` of each item in detail (list)\n        _items = []\n        if self.detail:\n            for _item_detail in self.detail:\n                if _item_detail:\n                    _items.append(_item_detail.to_dict())\n            _dict[\"detail\"] = _items\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of HTTPValidationError from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"detail\": [ValidationError.from_dict(_item) for _item in obj[\"detail\"]]\n            if obj.get(\"detail\") is not None\n            else None\n        })\n        return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/http_validation_error/#openapi_client.models.http_validation_error.HTTPValidationError.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/http_validation_error.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/openapi_client/models/http_validation_error/#openapi_client.models.http_validation_error.HTTPValidationError.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/http_validation_error.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/openapi_client/models/http_validation_error/#openapi_client.models.http_validation_error.HTTPValidationError.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of HTTPValidationError from a JSON string</p> Source code in <code>client/src/openapi_client/models/http_validation_error.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of HTTPValidationError from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/http_validation_error/#openapi_client.models.http_validation_error.HTTPValidationError.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>client/src/openapi_client/models/http_validation_error.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: set[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    # override the default output from pydantic by calling `to_dict()` of each item in detail (list)\n    _items = []\n    if self.detail:\n        for _item_detail in self.detail:\n            if _item_detail:\n                _items.append(_item_detail.to_dict())\n        _dict[\"detail\"] = _items\n    return _dict\n</code></pre>"},{"location":"reference/openapi_client/models/http_validation_error/#openapi_client.models.http_validation_error.HTTPValidationError.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of HTTPValidationError from a dict</p> Source code in <code>client/src/openapi_client/models/http_validation_error.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of HTTPValidationError from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"detail\": [ValidationError.from_dict(_item) for _item in obj[\"detail\"]]\n        if obj.get(\"detail\") is not None\n        else None\n    })\n    return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/job_options/","title":"job_options","text":"<p>the jobq cluster workflow management tool backend</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/job_options/#openapi_client.models.job_options.JobOptions","title":"JobOptions","text":"<p>               Bases: <code>BaseModel</code></p> <p>Options for customizing a Kubernetes job definition from a Python function.</p> Source code in <code>client/src/openapi_client/models/job_options.py</code> <pre><code>class JobOptions(BaseModel):\n    \"\"\"\n    Options for customizing a Kubernetes job definition from a Python function.\n    \"\"\"  # noqa: E501\n\n    resources: ResourceOptions | None = None\n    scheduling: SchedulingOptions\n    labels: dict[str, StrictStr] | None = None\n    __properties: ClassVar[list[str]] = [\"resources\", \"scheduling\", \"labels\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of JobOptions from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: set[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        # override the default output from pydantic by calling `to_dict()` of resources\n        if self.resources:\n            _dict[\"resources\"] = self.resources.to_dict()\n        # override the default output from pydantic by calling `to_dict()` of scheduling\n        if self.scheduling:\n            _dict[\"scheduling\"] = self.scheduling.to_dict()\n        # set to None if resources (nullable) is None\n        # and model_fields_set contains the field\n        if self.resources is None and \"resources\" in self.model_fields_set:\n            _dict[\"resources\"] = None\n\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of JobOptions from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"resources\": ResourceOptions.from_dict(obj[\"resources\"])\n            if obj.get(\"resources\") is not None\n            else None,\n            \"scheduling\": SchedulingOptions.from_dict(obj[\"scheduling\"])\n            if obj.get(\"scheduling\") is not None\n            else None,\n            \"labels\": obj.get(\"labels\"),\n        })\n        return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/job_options/#openapi_client.models.job_options.JobOptions.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/job_options.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/openapi_client/models/job_options/#openapi_client.models.job_options.JobOptions.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/job_options.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/openapi_client/models/job_options/#openapi_client.models.job_options.JobOptions.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of JobOptions from a JSON string</p> Source code in <code>client/src/openapi_client/models/job_options.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of JobOptions from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/job_options/#openapi_client.models.job_options.JobOptions.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>client/src/openapi_client/models/job_options.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: set[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    # override the default output from pydantic by calling `to_dict()` of resources\n    if self.resources:\n        _dict[\"resources\"] = self.resources.to_dict()\n    # override the default output from pydantic by calling `to_dict()` of scheduling\n    if self.scheduling:\n        _dict[\"scheduling\"] = self.scheduling.to_dict()\n    # set to None if resources (nullable) is None\n    # and model_fields_set contains the field\n    if self.resources is None and \"resources\" in self.model_fields_set:\n        _dict[\"resources\"] = None\n\n    return _dict\n</code></pre>"},{"location":"reference/openapi_client/models/job_options/#openapi_client.models.job_options.JobOptions.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of JobOptions from a dict</p> Source code in <code>client/src/openapi_client/models/job_options.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of JobOptions from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"resources\": ResourceOptions.from_dict(obj[\"resources\"])\n        if obj.get(\"resources\") is not None\n        else None,\n        \"scheduling\": SchedulingOptions.from_dict(obj[\"scheduling\"])\n        if obj.get(\"scheduling\") is not None\n        else None,\n        \"labels\": obj.get(\"labels\"),\n    })\n    return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/job_status/","title":"job_status","text":"<p>the jobq cluster workflow management tool backend</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/job_status/#openapi_client.models.job_status.JobStatus","title":"JobStatus","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>JobStatus</p> Source code in <code>client/src/openapi_client/models/job_status.py</code> <pre><code>class JobStatus(str, Enum):\n    \"\"\"\n    JobStatus\n    \"\"\"\n\n    \"\"\"\n    allowed enum values\n    \"\"\"\n    PENDING = \"pending\"\n    EXECUTING = \"executing\"\n    SUCCEEDED = \"succeeded\"\n    FAILED = \"failed\"\n    INADMISSIBLE = \"inadmissible\"\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self:\n        \"\"\"Create an instance of JobStatus from a JSON string\"\"\"\n        return cls(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/job_status/#openapi_client.models.job_status.JobStatus.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self\n</code></pre> <p>Create an instance of JobStatus from a JSON string</p> Source code in <code>client/src/openapi_client/models/job_status.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self:\n    \"\"\"Create an instance of JobStatus from a JSON string\"\"\"\n    return cls(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/list_workload_model/","title":"list_workload_model","text":"<p>the jobq cluster workflow management tool backend</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/list_workload_model/#openapi_client.models.list_workload_model.ListWorkloadModel","title":"ListWorkloadModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>ListWorkloadModel</p> Source code in <code>client/src/openapi_client/models/list_workload_model.py</code> <pre><code>class ListWorkloadModel(BaseModel):\n    \"\"\"\n    ListWorkloadModel\n    \"\"\"  # noqa: E501\n\n    name: StrictStr\n    id: WorkloadIdentifier\n    metadata: WorkloadMetadata | None = None\n    __properties: ClassVar[list[str]] = [\"name\", \"id\", \"metadata\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of ListWorkloadModel from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: set[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        # override the default output from pydantic by calling `to_dict()` of id\n        if self.id:\n            _dict[\"id\"] = self.id.to_dict()\n        # override the default output from pydantic by calling `to_dict()` of metadata\n        if self.metadata:\n            _dict[\"metadata\"] = self.metadata.to_dict()\n        # set to None if metadata (nullable) is None\n        # and model_fields_set contains the field\n        if self.metadata is None and \"metadata\" in self.model_fields_set:\n            _dict[\"metadata\"] = None\n\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of ListWorkloadModel from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"name\": obj.get(\"name\"),\n            \"id\": WorkloadIdentifier.from_dict(obj[\"id\"])\n            if obj.get(\"id\") is not None\n            else None,\n            \"metadata\": WorkloadMetadata.from_dict(obj[\"metadata\"])\n            if obj.get(\"metadata\") is not None\n            else None,\n        })\n        return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/list_workload_model/#openapi_client.models.list_workload_model.ListWorkloadModel.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/list_workload_model.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/openapi_client/models/list_workload_model/#openapi_client.models.list_workload_model.ListWorkloadModel.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/list_workload_model.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/openapi_client/models/list_workload_model/#openapi_client.models.list_workload_model.ListWorkloadModel.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of ListWorkloadModel from a JSON string</p> Source code in <code>client/src/openapi_client/models/list_workload_model.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of ListWorkloadModel from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/list_workload_model/#openapi_client.models.list_workload_model.ListWorkloadModel.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>client/src/openapi_client/models/list_workload_model.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: set[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    # override the default output from pydantic by calling `to_dict()` of id\n    if self.id:\n        _dict[\"id\"] = self.id.to_dict()\n    # override the default output from pydantic by calling `to_dict()` of metadata\n    if self.metadata:\n        _dict[\"metadata\"] = self.metadata.to_dict()\n    # set to None if metadata (nullable) is None\n    # and model_fields_set contains the field\n    if self.metadata is None and \"metadata\" in self.model_fields_set:\n        _dict[\"metadata\"] = None\n\n    return _dict\n</code></pre>"},{"location":"reference/openapi_client/models/list_workload_model/#openapi_client.models.list_workload_model.ListWorkloadModel.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of ListWorkloadModel from a dict</p> Source code in <code>client/src/openapi_client/models/list_workload_model.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of ListWorkloadModel from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"name\": obj.get(\"name\"),\n        \"id\": WorkloadIdentifier.from_dict(obj[\"id\"])\n        if obj.get(\"id\") is not None\n        else None,\n        \"metadata\": WorkloadMetadata.from_dict(obj[\"metadata\"])\n        if obj.get(\"metadata\") is not None\n        else None,\n    })\n    return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/resource_options/","title":"resource_options","text":"<p>the jobq cluster workflow management tool backend</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/resource_options/#openapi_client.models.resource_options.ResourceOptions","title":"ResourceOptions","text":"<p>               Bases: <code>BaseModel</code></p> <p>Options for requesting cluster compute resources for a <code>jobq.Job</code>.  Memory and CPU values need to be given as <code>&lt;num&gt; &lt;prefix&gt;</code>, where num is a floating point number, and prefix is one of the following SI metric prefixes:     * <code>m, k, M, G, T</code> (base 10)     * <code>Ki, Mi, Gi, Ti</code> (base 2).</p> Source code in <code>client/src/openapi_client/models/resource_options.py</code> <pre><code>class ResourceOptions(BaseModel):\n    \"\"\"\n    Options for requesting cluster compute resources for a ``jobq.Job``.  Memory and CPU values need to be given as ``&lt;num&gt; &lt;prefix&gt;``, where num is a floating point number, and prefix is one of the following SI metric prefixes:     * ``m, k, M, G, T`` (base 10)     * ``Ki, Mi, Gi, Ti`` (base 2).\n    \"\"\"  # noqa: E501\n\n    memory: StrictStr | None = None\n    cpu: StrictStr | None = None\n    gpu: StrictInt | None = None\n    __properties: ClassVar[list[str]] = [\"memory\", \"cpu\", \"gpu\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of ResourceOptions from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: set[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        # set to None if memory (nullable) is None\n        # and model_fields_set contains the field\n        if self.memory is None and \"memory\" in self.model_fields_set:\n            _dict[\"memory\"] = None\n\n        # set to None if cpu (nullable) is None\n        # and model_fields_set contains the field\n        if self.cpu is None and \"cpu\" in self.model_fields_set:\n            _dict[\"cpu\"] = None\n\n        # set to None if gpu (nullable) is None\n        # and model_fields_set contains the field\n        if self.gpu is None and \"gpu\" in self.model_fields_set:\n            _dict[\"gpu\"] = None\n\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of ResourceOptions from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"memory\": obj.get(\"memory\"),\n            \"cpu\": obj.get(\"cpu\"),\n            \"gpu\": obj.get(\"gpu\"),\n        })\n        return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/resource_options/#openapi_client.models.resource_options.ResourceOptions.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/resource_options.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/openapi_client/models/resource_options/#openapi_client.models.resource_options.ResourceOptions.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/resource_options.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/openapi_client/models/resource_options/#openapi_client.models.resource_options.ResourceOptions.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of ResourceOptions from a JSON string</p> Source code in <code>client/src/openapi_client/models/resource_options.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of ResourceOptions from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/resource_options/#openapi_client.models.resource_options.ResourceOptions.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>client/src/openapi_client/models/resource_options.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: set[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    # set to None if memory (nullable) is None\n    # and model_fields_set contains the field\n    if self.memory is None and \"memory\" in self.model_fields_set:\n        _dict[\"memory\"] = None\n\n    # set to None if cpu (nullable) is None\n    # and model_fields_set contains the field\n    if self.cpu is None and \"cpu\" in self.model_fields_set:\n        _dict[\"cpu\"] = None\n\n    # set to None if gpu (nullable) is None\n    # and model_fields_set contains the field\n    if self.gpu is None and \"gpu\" in self.model_fields_set:\n        _dict[\"gpu\"] = None\n\n    return _dict\n</code></pre>"},{"location":"reference/openapi_client/models/resource_options/#openapi_client.models.resource_options.ResourceOptions.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of ResourceOptions from a dict</p> Source code in <code>client/src/openapi_client/models/resource_options.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of ResourceOptions from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"memory\": obj.get(\"memory\"),\n        \"cpu\": obj.get(\"cpu\"),\n        \"gpu\": obj.get(\"gpu\"),\n    })\n    return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/scheduling_options/","title":"scheduling_options","text":"<p>the jobq cluster workflow management tool backend</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/scheduling_options/#openapi_client.models.scheduling_options.SchedulingOptions","title":"SchedulingOptions","text":"<p>               Bases: <code>BaseModel</code></p> <p>Options configuring a <code>jobq.Job</code>'s priority in the cluster, and the Kueue cluster queue name the job should be submitted to.</p> Source code in <code>client/src/openapi_client/models/scheduling_options.py</code> <pre><code>class SchedulingOptions(BaseModel):\n    \"\"\"\n    Options configuring a ``jobq.Job``'s priority in the cluster, and the Kueue cluster queue name the job should be submitted to.\n    \"\"\"  # noqa: E501\n\n    priority_class: StrictStr | None = None\n    queue_name: StrictStr\n    __properties: ClassVar[list[str]] = [\"priority_class\", \"queue_name\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of SchedulingOptions from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: set[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        # set to None if priority_class (nullable) is None\n        # and model_fields_set contains the field\n        if self.priority_class is None and \"priority_class\" in self.model_fields_set:\n            _dict[\"priority_class\"] = None\n\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of SchedulingOptions from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"priority_class\": obj.get(\"priority_class\"),\n            \"queue_name\": obj.get(\"queue_name\"),\n        })\n        return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/scheduling_options/#openapi_client.models.scheduling_options.SchedulingOptions.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/scheduling_options.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/openapi_client/models/scheduling_options/#openapi_client.models.scheduling_options.SchedulingOptions.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/scheduling_options.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/openapi_client/models/scheduling_options/#openapi_client.models.scheduling_options.SchedulingOptions.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of SchedulingOptions from a JSON string</p> Source code in <code>client/src/openapi_client/models/scheduling_options.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of SchedulingOptions from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/scheduling_options/#openapi_client.models.scheduling_options.SchedulingOptions.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>client/src/openapi_client/models/scheduling_options.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: set[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    # set to None if priority_class (nullable) is None\n    # and model_fields_set contains the field\n    if self.priority_class is None and \"priority_class\" in self.model_fields_set:\n        _dict[\"priority_class\"] = None\n\n    return _dict\n</code></pre>"},{"location":"reference/openapi_client/models/scheduling_options/#openapi_client.models.scheduling_options.SchedulingOptions.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of SchedulingOptions from a dict</p> Source code in <code>client/src/openapi_client/models/scheduling_options.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of SchedulingOptions from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"priority_class\": obj.get(\"priority_class\"),\n        \"queue_name\": obj.get(\"queue_name\"),\n    })\n    return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/validation_error/","title":"validation_error","text":"<p>the jobq cluster workflow management tool backend</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/validation_error/#openapi_client.models.validation_error.ValidationError","title":"ValidationError","text":"<p>               Bases: <code>BaseModel</code></p> <p>ValidationError</p> Source code in <code>client/src/openapi_client/models/validation_error.py</code> <pre><code>class ValidationError(BaseModel):\n    \"\"\"\n    ValidationError\n    \"\"\"  # noqa: E501\n\n    loc: list[ValidationErrorLocInner]\n    msg: StrictStr\n    type: StrictStr\n    __properties: ClassVar[list[str]] = [\"loc\", \"msg\", \"type\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of ValidationError from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: set[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        # override the default output from pydantic by calling `to_dict()` of each item in loc (list)\n        _items = []\n        if self.loc:\n            for _item_loc in self.loc:\n                if _item_loc:\n                    _items.append(_item_loc.to_dict())\n            _dict[\"loc\"] = _items\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of ValidationError from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"loc\": [ValidationErrorLocInner.from_dict(_item) for _item in obj[\"loc\"]]\n            if obj.get(\"loc\") is not None\n            else None,\n            \"msg\": obj.get(\"msg\"),\n            \"type\": obj.get(\"type\"),\n        })\n        return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/validation_error/#openapi_client.models.validation_error.ValidationError.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/validation_error.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/openapi_client/models/validation_error/#openapi_client.models.validation_error.ValidationError.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/validation_error.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/openapi_client/models/validation_error/#openapi_client.models.validation_error.ValidationError.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of ValidationError from a JSON string</p> Source code in <code>client/src/openapi_client/models/validation_error.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of ValidationError from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/validation_error/#openapi_client.models.validation_error.ValidationError.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>client/src/openapi_client/models/validation_error.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: set[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    # override the default output from pydantic by calling `to_dict()` of each item in loc (list)\n    _items = []\n    if self.loc:\n        for _item_loc in self.loc:\n            if _item_loc:\n                _items.append(_item_loc.to_dict())\n        _dict[\"loc\"] = _items\n    return _dict\n</code></pre>"},{"location":"reference/openapi_client/models/validation_error/#openapi_client.models.validation_error.ValidationError.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of ValidationError from a dict</p> Source code in <code>client/src/openapi_client/models/validation_error.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of ValidationError from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"loc\": [ValidationErrorLocInner.from_dict(_item) for _item in obj[\"loc\"]]\n        if obj.get(\"loc\") is not None\n        else None,\n        \"msg\": obj.get(\"msg\"),\n        \"type\": obj.get(\"type\"),\n    })\n    return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/validation_error_loc_inner/","title":"validation_error_loc_inner","text":"<p>the jobq cluster workflow management tool backend</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/validation_error_loc_inner/#openapi_client.models.validation_error_loc_inner.ValidationErrorLocInner","title":"ValidationErrorLocInner","text":"<p>               Bases: <code>BaseModel</code></p> <p>ValidationErrorLocInner</p> Source code in <code>client/src/openapi_client/models/validation_error_loc_inner.py</code> <pre><code>class ValidationErrorLocInner(BaseModel):\n    \"\"\"\n    ValidationErrorLocInner\n    \"\"\"\n\n    # data type: str\n    anyof_schema_1_validator: StrictStr | None = None\n    # data type: int\n    anyof_schema_2_validator: StrictInt | None = None\n    if TYPE_CHECKING:\n        actual_instance: int | str | None = None\n    else:\n        actual_instance: Any = None\n    any_of_schemas: set[str] = {\"int\", \"str\"}\n\n    model_config = {\n        \"validate_assignment\": True,\n        \"protected_namespaces\": (),\n    }\n\n    def __init__(self, *args, **kwargs) -&gt; None:\n        if args:\n            if len(args) &gt; 1:\n                raise ValueError(\n                    \"If a position argument is used, only 1 is allowed to set `actual_instance`\"\n                )\n            if kwargs:\n                raise ValueError(\n                    \"If a position argument is used, keyword arguments cannot be used.\"\n                )\n            super().__init__(actual_instance=args[0])\n        else:\n            super().__init__(**kwargs)\n\n    @field_validator(\"actual_instance\")\n    def actual_instance_must_validate_anyof(cls, v):\n        instance = ValidationErrorLocInner.model_construct()\n        error_messages = []\n        # validate data type: str\n        try:\n            instance.anyof_schema_1_validator = v\n            return v\n        except (ValidationError, ValueError) as e:\n            error_messages.append(str(e))\n        # validate data type: int\n        try:\n            instance.anyof_schema_2_validator = v\n            return v\n        except (ValidationError, ValueError) as e:\n            error_messages.append(str(e))\n        if error_messages:\n            # no match\n            raise ValueError(\n                \"No match found when setting the actual_instance in ValidationErrorLocInner with anyOf schemas: int, str. Details: \"\n                + \", \".join(error_messages)\n            )\n        else:\n            return v\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any]) -&gt; Self:\n        return cls.from_json(json.dumps(obj))\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self:\n        \"\"\"Returns the object represented by the json string\"\"\"\n        instance = cls.model_construct()\n        error_messages = []\n        # deserialize data into str\n        try:\n            # validation\n            instance.anyof_schema_1_validator = json.loads(json_str)\n            # assign value to actual_instance\n            instance.actual_instance = instance.anyof_schema_1_validator\n            return instance\n        except (ValidationError, ValueError) as e:\n            error_messages.append(str(e))\n        # deserialize data into int\n        try:\n            # validation\n            instance.anyof_schema_2_validator = json.loads(json_str)\n            # assign value to actual_instance\n            instance.actual_instance = instance.anyof_schema_2_validator\n            return instance\n        except (ValidationError, ValueError) as e:\n            error_messages.append(str(e))\n\n        if error_messages:\n            # no match\n            raise ValueError(\n                \"No match found when deserializing the JSON string into ValidationErrorLocInner with anyOf schemas: int, str. Details: \"\n                + \", \".join(error_messages)\n            )\n        else:\n            return instance\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the actual instance\"\"\"\n        if self.actual_instance is None:\n            return \"null\"\n\n        if hasattr(self.actual_instance, \"to_json\") and callable(\n            self.actual_instance.to_json\n        ):\n            return self.actual_instance.to_json()\n        else:\n            return json.dumps(self.actual_instance)\n\n    def to_dict(self) -&gt; dict[str, Any] | int | str | None:\n        \"\"\"Returns the dict representation of the actual instance\"\"\"\n        if self.actual_instance is None:\n            return None\n\n        if hasattr(self.actual_instance, \"to_dict\") and callable(\n            self.actual_instance.to_dict\n        ):\n            return self.actual_instance.to_dict()\n        else:\n            return self.actual_instance\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the actual instance\"\"\"\n        return pprint.pformat(self.model_dump())\n</code></pre>"},{"location":"reference/openapi_client/models/validation_error_loc_inner/#openapi_client.models.validation_error_loc_inner.ValidationErrorLocInner.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self\n</code></pre> <p>Returns the object represented by the json string</p> Source code in <code>client/src/openapi_client/models/validation_error_loc_inner.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self:\n    \"\"\"Returns the object represented by the json string\"\"\"\n    instance = cls.model_construct()\n    error_messages = []\n    # deserialize data into str\n    try:\n        # validation\n        instance.anyof_schema_1_validator = json.loads(json_str)\n        # assign value to actual_instance\n        instance.actual_instance = instance.anyof_schema_1_validator\n        return instance\n    except (ValidationError, ValueError) as e:\n        error_messages.append(str(e))\n    # deserialize data into int\n    try:\n        # validation\n        instance.anyof_schema_2_validator = json.loads(json_str)\n        # assign value to actual_instance\n        instance.actual_instance = instance.anyof_schema_2_validator\n        return instance\n    except (ValidationError, ValueError) as e:\n        error_messages.append(str(e))\n\n    if error_messages:\n        # no match\n        raise ValueError(\n            \"No match found when deserializing the JSON string into ValidationErrorLocInner with anyOf schemas: int, str. Details: \"\n            + \", \".join(error_messages)\n        )\n    else:\n        return instance\n</code></pre>"},{"location":"reference/openapi_client/models/validation_error_loc_inner/#openapi_client.models.validation_error_loc_inner.ValidationErrorLocInner.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the actual instance</p> Source code in <code>client/src/openapi_client/models/validation_error_loc_inner.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the actual instance\"\"\"\n    if self.actual_instance is None:\n        return \"null\"\n\n    if hasattr(self.actual_instance, \"to_json\") and callable(\n        self.actual_instance.to_json\n    ):\n        return self.actual_instance.to_json()\n    else:\n        return json.dumps(self.actual_instance)\n</code></pre>"},{"location":"reference/openapi_client/models/validation_error_loc_inner/#openapi_client.models.validation_error_loc_inner.ValidationErrorLocInner.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any] | int | str | None\n</code></pre> <p>Returns the dict representation of the actual instance</p> Source code in <code>client/src/openapi_client/models/validation_error_loc_inner.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any] | int | str | None:\n    \"\"\"Returns the dict representation of the actual instance\"\"\"\n    if self.actual_instance is None:\n        return None\n\n    if hasattr(self.actual_instance, \"to_dict\") and callable(\n        self.actual_instance.to_dict\n    ):\n        return self.actual_instance.to_dict()\n    else:\n        return self.actual_instance\n</code></pre>"},{"location":"reference/openapi_client/models/validation_error_loc_inner/#openapi_client.models.validation_error_loc_inner.ValidationErrorLocInner.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the actual instance</p> Source code in <code>client/src/openapi_client/models/validation_error_loc_inner.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the actual instance\"\"\"\n    return pprint.pformat(self.model_dump())\n</code></pre>"},{"location":"reference/openapi_client/models/workload_admission/","title":"workload_admission","text":"<p>the jobq cluster workflow management tool backend</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/workload_admission/#openapi_client.models.workload_admission.WorkloadAdmission","title":"WorkloadAdmission","text":"<p>               Bases: <code>BaseModel</code></p> <p>WorkloadAdmission</p> Source code in <code>client/src/openapi_client/models/workload_admission.py</code> <pre><code>class WorkloadAdmission(BaseModel):\n    \"\"\"\n    WorkloadAdmission\n    \"\"\"  # noqa: E501\n\n    cluster_queue: StrictStr = Field(alias=\"clusterQueue\")\n    pod_set_assignments: list[Any] = Field(alias=\"podSetAssignments\")\n    __properties: ClassVar[list[str]] = [\"clusterQueue\", \"podSetAssignments\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of WorkloadAdmission from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: set[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of WorkloadAdmission from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"clusterQueue\": obj.get(\"clusterQueue\"),\n            \"podSetAssignments\": obj.get(\"podSetAssignments\"),\n        })\n        return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/workload_admission/#openapi_client.models.workload_admission.WorkloadAdmission.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/workload_admission.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/openapi_client/models/workload_admission/#openapi_client.models.workload_admission.WorkloadAdmission.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/workload_admission.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/openapi_client/models/workload_admission/#openapi_client.models.workload_admission.WorkloadAdmission.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of WorkloadAdmission from a JSON string</p> Source code in <code>client/src/openapi_client/models/workload_admission.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of WorkloadAdmission from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/workload_admission/#openapi_client.models.workload_admission.WorkloadAdmission.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>client/src/openapi_client/models/workload_admission.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: set[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    return _dict\n</code></pre>"},{"location":"reference/openapi_client/models/workload_admission/#openapi_client.models.workload_admission.WorkloadAdmission.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of WorkloadAdmission from a dict</p> Source code in <code>client/src/openapi_client/models/workload_admission.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of WorkloadAdmission from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"clusterQueue\": obj.get(\"clusterQueue\"),\n        \"podSetAssignments\": obj.get(\"podSetAssignments\"),\n    })\n    return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/workload_identifier/","title":"workload_identifier","text":"<p>the jobq cluster workflow management tool backend</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/workload_identifier/#openapi_client.models.workload_identifier.WorkloadIdentifier","title":"WorkloadIdentifier","text":"<p>               Bases: <code>BaseModel</code></p> <p>Identifier for a workload in a Kubernetes cluster</p> Source code in <code>client/src/openapi_client/models/workload_identifier.py</code> <pre><code>class WorkloadIdentifier(BaseModel):\n    \"\"\"\n    Identifier for a workload in a Kubernetes cluster\n    \"\"\"  # noqa: E501\n\n    group: StrictStr\n    version: StrictStr\n    kind: StrictStr\n    namespace: StrictStr\n    uid: StrictStr\n    __properties: ClassVar[list[str]] = [\"group\", \"version\", \"kind\", \"namespace\", \"uid\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of WorkloadIdentifier from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: set[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of WorkloadIdentifier from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"group\": obj.get(\"group\"),\n            \"version\": obj.get(\"version\"),\n            \"kind\": obj.get(\"kind\"),\n            \"namespace\": obj.get(\"namespace\"),\n            \"uid\": obj.get(\"uid\"),\n        })\n        return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/workload_identifier/#openapi_client.models.workload_identifier.WorkloadIdentifier.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/workload_identifier.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/openapi_client/models/workload_identifier/#openapi_client.models.workload_identifier.WorkloadIdentifier.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/workload_identifier.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/openapi_client/models/workload_identifier/#openapi_client.models.workload_identifier.WorkloadIdentifier.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of WorkloadIdentifier from a JSON string</p> Source code in <code>client/src/openapi_client/models/workload_identifier.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of WorkloadIdentifier from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/workload_identifier/#openapi_client.models.workload_identifier.WorkloadIdentifier.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>client/src/openapi_client/models/workload_identifier.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: set[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    return _dict\n</code></pre>"},{"location":"reference/openapi_client/models/workload_identifier/#openapi_client.models.workload_identifier.WorkloadIdentifier.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of WorkloadIdentifier from a dict</p> Source code in <code>client/src/openapi_client/models/workload_identifier.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of WorkloadIdentifier from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"group\": obj.get(\"group\"),\n        \"version\": obj.get(\"version\"),\n        \"kind\": obj.get(\"kind\"),\n        \"namespace\": obj.get(\"namespace\"),\n        \"uid\": obj.get(\"uid\"),\n    })\n    return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/workload_metadata/","title":"workload_metadata","text":"<p>the jobq cluster workflow management tool backend</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/workload_metadata/#openapi_client.models.workload_metadata.WorkloadMetadata","title":"WorkloadMetadata","text":"<p>               Bases: <code>BaseModel</code></p> <p>WorkloadMetadata</p> Source code in <code>client/src/openapi_client/models/workload_metadata.py</code> <pre><code>class WorkloadMetadata(BaseModel):\n    \"\"\"\n    WorkloadMetadata\n    \"\"\"  # noqa: E501\n\n    managed_resource_id: StrictStr\n    execution_status: JobStatus\n    spec: WorkloadSpec\n    kueue_status: WorkloadStatus\n    submission_timestamp: datetime\n    last_admission_timestamp: datetime | None = None\n    termination_timestamp: datetime | None = None\n    was_evicted: StrictBool | None = False\n    was_inadmissible: StrictBool | None = False\n    has_failed_pods: StrictBool | None = False\n    __properties: ClassVar[list[str]] = [\n        \"managed_resource_id\",\n        \"execution_status\",\n        \"spec\",\n        \"kueue_status\",\n        \"submission_timestamp\",\n        \"last_admission_timestamp\",\n        \"termination_timestamp\",\n        \"was_evicted\",\n        \"was_inadmissible\",\n        \"has_failed_pods\",\n    ]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of WorkloadMetadata from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: set[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        # override the default output from pydantic by calling `to_dict()` of spec\n        if self.spec:\n            _dict[\"spec\"] = self.spec.to_dict()\n        # override the default output from pydantic by calling `to_dict()` of kueue_status\n        if self.kueue_status:\n            _dict[\"kueue_status\"] = self.kueue_status.to_dict()\n        # set to None if last_admission_timestamp (nullable) is None\n        # and model_fields_set contains the field\n        if (\n            self.last_admission_timestamp is None\n            and \"last_admission_timestamp\" in self.model_fields_set\n        ):\n            _dict[\"last_admission_timestamp\"] = None\n\n        # set to None if termination_timestamp (nullable) is None\n        # and model_fields_set contains the field\n        if (\n            self.termination_timestamp is None\n            and \"termination_timestamp\" in self.model_fields_set\n        ):\n            _dict[\"termination_timestamp\"] = None\n\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of WorkloadMetadata from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"managed_resource_id\": obj.get(\"managed_resource_id\"),\n            \"execution_status\": obj.get(\"execution_status\"),\n            \"spec\": WorkloadSpec.from_dict(obj[\"spec\"])\n            if obj.get(\"spec\") is not None\n            else None,\n            \"kueue_status\": WorkloadStatus.from_dict(obj[\"kueue_status\"])\n            if obj.get(\"kueue_status\") is not None\n            else None,\n            \"submission_timestamp\": obj.get(\"submission_timestamp\"),\n            \"last_admission_timestamp\": obj.get(\"last_admission_timestamp\"),\n            \"termination_timestamp\": obj.get(\"termination_timestamp\"),\n            \"was_evicted\": obj.get(\"was_evicted\")\n            if obj.get(\"was_evicted\") is not None\n            else False,\n            \"was_inadmissible\": obj.get(\"was_inadmissible\")\n            if obj.get(\"was_inadmissible\") is not None\n            else False,\n            \"has_failed_pods\": obj.get(\"has_failed_pods\")\n            if obj.get(\"has_failed_pods\") is not None\n            else False,\n        })\n        return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/workload_metadata/#openapi_client.models.workload_metadata.WorkloadMetadata.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/workload_metadata.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/openapi_client/models/workload_metadata/#openapi_client.models.workload_metadata.WorkloadMetadata.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/workload_metadata.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/openapi_client/models/workload_metadata/#openapi_client.models.workload_metadata.WorkloadMetadata.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of WorkloadMetadata from a JSON string</p> Source code in <code>client/src/openapi_client/models/workload_metadata.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of WorkloadMetadata from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/workload_metadata/#openapi_client.models.workload_metadata.WorkloadMetadata.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>client/src/openapi_client/models/workload_metadata.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: set[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    # override the default output from pydantic by calling `to_dict()` of spec\n    if self.spec:\n        _dict[\"spec\"] = self.spec.to_dict()\n    # override the default output from pydantic by calling `to_dict()` of kueue_status\n    if self.kueue_status:\n        _dict[\"kueue_status\"] = self.kueue_status.to_dict()\n    # set to None if last_admission_timestamp (nullable) is None\n    # and model_fields_set contains the field\n    if (\n        self.last_admission_timestamp is None\n        and \"last_admission_timestamp\" in self.model_fields_set\n    ):\n        _dict[\"last_admission_timestamp\"] = None\n\n    # set to None if termination_timestamp (nullable) is None\n    # and model_fields_set contains the field\n    if (\n        self.termination_timestamp is None\n        and \"termination_timestamp\" in self.model_fields_set\n    ):\n        _dict[\"termination_timestamp\"] = None\n\n    return _dict\n</code></pre>"},{"location":"reference/openapi_client/models/workload_metadata/#openapi_client.models.workload_metadata.WorkloadMetadata.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of WorkloadMetadata from a dict</p> Source code in <code>client/src/openapi_client/models/workload_metadata.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of WorkloadMetadata from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"managed_resource_id\": obj.get(\"managed_resource_id\"),\n        \"execution_status\": obj.get(\"execution_status\"),\n        \"spec\": WorkloadSpec.from_dict(obj[\"spec\"])\n        if obj.get(\"spec\") is not None\n        else None,\n        \"kueue_status\": WorkloadStatus.from_dict(obj[\"kueue_status\"])\n        if obj.get(\"kueue_status\") is not None\n        else None,\n        \"submission_timestamp\": obj.get(\"submission_timestamp\"),\n        \"last_admission_timestamp\": obj.get(\"last_admission_timestamp\"),\n        \"termination_timestamp\": obj.get(\"termination_timestamp\"),\n        \"was_evicted\": obj.get(\"was_evicted\")\n        if obj.get(\"was_evicted\") is not None\n        else False,\n        \"was_inadmissible\": obj.get(\"was_inadmissible\")\n        if obj.get(\"was_inadmissible\") is not None\n        else False,\n        \"has_failed_pods\": obj.get(\"has_failed_pods\")\n        if obj.get(\"has_failed_pods\") is not None\n        else False,\n    })\n    return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/workload_spec/","title":"workload_spec","text":"<p>the jobq cluster workflow management tool backend</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/workload_spec/#openapi_client.models.workload_spec.WorkloadSpec","title":"WorkloadSpec","text":"<p>               Bases: <code>BaseModel</code></p> <p>WorkloadSpec</p> Source code in <code>client/src/openapi_client/models/workload_spec.py</code> <pre><code>class WorkloadSpec(BaseModel):\n    \"\"\"\n    WorkloadSpec\n    \"\"\"  # noqa: E501\n\n    pod_sets: list[Any] = Field(alias=\"podSets\")\n    queue_name: StrictStr = Field(alias=\"queueName\")\n    active: StrictBool\n    priority_class_name: StrictStr | None = Field(\n        default=None, alias=\"priorityClassName\"\n    )\n    priority: StrictInt | None = None\n    priority_class_source: StrictStr | None = Field(\n        default=None, alias=\"priorityClassSource\"\n    )\n    __properties: ClassVar[list[str]] = [\n        \"podSets\",\n        \"queueName\",\n        \"active\",\n        \"priorityClassName\",\n        \"priority\",\n        \"priorityClassSource\",\n    ]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of WorkloadSpec from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: set[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        # set to None if priority_class_name (nullable) is None\n        # and model_fields_set contains the field\n        if (\n            self.priority_class_name is None\n            and \"priority_class_name\" in self.model_fields_set\n        ):\n            _dict[\"priorityClassName\"] = None\n\n        # set to None if priority (nullable) is None\n        # and model_fields_set contains the field\n        if self.priority is None and \"priority\" in self.model_fields_set:\n            _dict[\"priority\"] = None\n\n        # set to None if priority_class_source (nullable) is None\n        # and model_fields_set contains the field\n        if (\n            self.priority_class_source is None\n            and \"priority_class_source\" in self.model_fields_set\n        ):\n            _dict[\"priorityClassSource\"] = None\n\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of WorkloadSpec from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"podSets\": obj.get(\"podSets\"),\n            \"queueName\": obj.get(\"queueName\"),\n            \"active\": obj.get(\"active\"),\n            \"priorityClassName\": obj.get(\"priorityClassName\"),\n            \"priority\": obj.get(\"priority\"),\n            \"priorityClassSource\": obj.get(\"priorityClassSource\"),\n        })\n        return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/workload_spec/#openapi_client.models.workload_spec.WorkloadSpec.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/workload_spec.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/openapi_client/models/workload_spec/#openapi_client.models.workload_spec.WorkloadSpec.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/workload_spec.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/openapi_client/models/workload_spec/#openapi_client.models.workload_spec.WorkloadSpec.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of WorkloadSpec from a JSON string</p> Source code in <code>client/src/openapi_client/models/workload_spec.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of WorkloadSpec from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/workload_spec/#openapi_client.models.workload_spec.WorkloadSpec.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>client/src/openapi_client/models/workload_spec.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: set[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    # set to None if priority_class_name (nullable) is None\n    # and model_fields_set contains the field\n    if (\n        self.priority_class_name is None\n        and \"priority_class_name\" in self.model_fields_set\n    ):\n        _dict[\"priorityClassName\"] = None\n\n    # set to None if priority (nullable) is None\n    # and model_fields_set contains the field\n    if self.priority is None and \"priority\" in self.model_fields_set:\n        _dict[\"priority\"] = None\n\n    # set to None if priority_class_source (nullable) is None\n    # and model_fields_set contains the field\n    if (\n        self.priority_class_source is None\n        and \"priority_class_source\" in self.model_fields_set\n    ):\n        _dict[\"priorityClassSource\"] = None\n\n    return _dict\n</code></pre>"},{"location":"reference/openapi_client/models/workload_spec/#openapi_client.models.workload_spec.WorkloadSpec.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of WorkloadSpec from a dict</p> Source code in <code>client/src/openapi_client/models/workload_spec.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of WorkloadSpec from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"podSets\": obj.get(\"podSets\"),\n        \"queueName\": obj.get(\"queueName\"),\n        \"active\": obj.get(\"active\"),\n        \"priorityClassName\": obj.get(\"priorityClassName\"),\n        \"priority\": obj.get(\"priority\"),\n        \"priorityClassSource\": obj.get(\"priorityClassSource\"),\n    })\n    return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/workload_status/","title":"workload_status","text":"<p>the jobq cluster workflow management tool backend</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/workload_status/#openapi_client.models.workload_status.WorkloadStatus","title":"WorkloadStatus","text":"<p>               Bases: <code>BaseModel</code></p> <p>WorkloadStatus</p> Source code in <code>client/src/openapi_client/models/workload_status.py</code> <pre><code>class WorkloadStatus(BaseModel):\n    \"\"\"\n    WorkloadStatus\n    \"\"\"  # noqa: E501\n\n    conditions: list[dict[str, Any]]\n    admission: WorkloadAdmission | None = None\n    requeue_state: dict[str, Any] | None = Field(default=None, alias=\"requeueState\")\n    reclaimable_pods: list[Any] | None = Field(default=None, alias=\"reclaimablePods\")\n    admission_checks: list[Any] | None = Field(default=None, alias=\"admissionChecks\")\n    __properties: ClassVar[list[str]] = [\n        \"conditions\",\n        \"admission\",\n        \"requeueState\",\n        \"reclaimablePods\",\n        \"admissionChecks\",\n    ]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of WorkloadStatus from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: set[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        # override the default output from pydantic by calling `to_dict()` of admission\n        if self.admission:\n            _dict[\"admission\"] = self.admission.to_dict()\n        # set to None if admission (nullable) is None\n        # and model_fields_set contains the field\n        if self.admission is None and \"admission\" in self.model_fields_set:\n            _dict[\"admission\"] = None\n\n        # set to None if requeue_state (nullable) is None\n        # and model_fields_set contains the field\n        if self.requeue_state is None and \"requeue_state\" in self.model_fields_set:\n            _dict[\"requeueState\"] = None\n\n        # set to None if reclaimable_pods (nullable) is None\n        # and model_fields_set contains the field\n        if (\n            self.reclaimable_pods is None\n            and \"reclaimable_pods\" in self.model_fields_set\n        ):\n            _dict[\"reclaimablePods\"] = None\n\n        # set to None if admission_checks (nullable) is None\n        # and model_fields_set contains the field\n        if (\n            self.admission_checks is None\n            and \"admission_checks\" in self.model_fields_set\n        ):\n            _dict[\"admissionChecks\"] = None\n\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of WorkloadStatus from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"conditions\": obj.get(\"conditions\"),\n            \"admission\": WorkloadAdmission.from_dict(obj[\"admission\"])\n            if obj.get(\"admission\") is not None\n            else None,\n            \"requeueState\": obj.get(\"requeueState\"),\n            \"reclaimablePods\": obj.get(\"reclaimablePods\"),\n            \"admissionChecks\": obj.get(\"admissionChecks\"),\n        })\n        return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/workload_status/#openapi_client.models.workload_status.WorkloadStatus.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/workload_status.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/openapi_client/models/workload_status/#openapi_client.models.workload_status.WorkloadStatus.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>client/src/openapi_client/models/workload_status.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/openapi_client/models/workload_status/#openapi_client.models.workload_status.WorkloadStatus.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of WorkloadStatus from a JSON string</p> Source code in <code>client/src/openapi_client/models/workload_status.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of WorkloadStatus from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/workload_status/#openapi_client.models.workload_status.WorkloadStatus.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>client/src/openapi_client/models/workload_status.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: set[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    # override the default output from pydantic by calling `to_dict()` of admission\n    if self.admission:\n        _dict[\"admission\"] = self.admission.to_dict()\n    # set to None if admission (nullable) is None\n    # and model_fields_set contains the field\n    if self.admission is None and \"admission\" in self.model_fields_set:\n        _dict[\"admission\"] = None\n\n    # set to None if requeue_state (nullable) is None\n    # and model_fields_set contains the field\n    if self.requeue_state is None and \"requeue_state\" in self.model_fields_set:\n        _dict[\"requeueState\"] = None\n\n    # set to None if reclaimable_pods (nullable) is None\n    # and model_fields_set contains the field\n    if (\n        self.reclaimable_pods is None\n        and \"reclaimable_pods\" in self.model_fields_set\n    ):\n        _dict[\"reclaimablePods\"] = None\n\n    # set to None if admission_checks (nullable) is None\n    # and model_fields_set contains the field\n    if (\n        self.admission_checks is None\n        and \"admission_checks\" in self.model_fields_set\n    ):\n        _dict[\"admissionChecks\"] = None\n\n    return _dict\n</code></pre>"},{"location":"reference/openapi_client/models/workload_status/#openapi_client.models.workload_status.WorkloadStatus.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of WorkloadStatus from a dict</p> Source code in <code>client/src/openapi_client/models/workload_status.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of WorkloadStatus from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"conditions\": obj.get(\"conditions\"),\n        \"admission\": WorkloadAdmission.from_dict(obj[\"admission\"])\n        if obj.get(\"admission\") is not None\n        else None,\n        \"requeueState\": obj.get(\"requeueState\"),\n        \"reclaimablePods\": obj.get(\"reclaimablePods\"),\n        \"admissionChecks\": obj.get(\"admissionChecks\"),\n    })\n    return _obj\n</code></pre>"}]}